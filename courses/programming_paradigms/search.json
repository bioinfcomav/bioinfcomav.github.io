[
  {
    "objectID": "objects_and_classes.html",
    "href": "objects_and_classes.html",
    "title": "Object oriented programming",
    "section": "",
    "text": "For decades procedural programming was the main tool to structure and divide software into little pieces, but around 1980 a new paradigm became popular: Object Oriented Programming (OOP). However, OOP did not replaced procedural programming, both paradigms still coexist, and, to this day, both of them are the most common programming paradigms. There are languages, like C, that only use functions, others like Java, that only use classes, the building block in Object Oriented Programming languages, and still others, like Python and Rust, are multiparadigmatic: the programmer choses.",
    "crumbs": [
      "Objects and classes"
    ]
  },
  {
    "objectID": "objects_and_classes.html#classes",
    "href": "objects_and_classes.html#classes",
    "title": "Object oriented programming",
    "section": "Classes",
    "text": "Classes\nIn Object Oriented Programming the class is the main building block. To introduce the concept of the classes let’s write a small program, using first a procedural approach.\n\n\n\n\n\n\nNow let’s do the same, but using classes. (In general any program that you can think of can be programmed using both paradigms).\n\n\n\n\n\n\nThere’s quite a bit to unpack here. We have defined a class with three methods: init, calc_area, and print.\nA method is a function defined within a class. Methods are called with the syntax “object.method_name()”. This is a syntax that you have already seen many times in Python, e.g. text_string.upper() or my_list.append(item).\nIn this class, Rectangle, there is a special method: init. Every time that we want to initialize an object, the class uses this special method. You can create Python classes without the init method, but this is because Python will create a default __init__method for you.\nIn the previous example the class that we have defined is Rectangle, and we have also created two objects of that class: rectangle1 and rectangle2. An object is an instance of the class, in this case every object is a particular rectangle, with its width and height.\nThe class has properties, data associated, like, in this case, width and height, and also, its methods define some behaviours. Methods are functions and functions are actions that act on data. So a class has methods, actions, behaviors, and objects have data associated to them and the behaviours provided by the class methods. Sometimes it is useful to think of a class as the representation of a type of thing, like rectangles, cars, or web servers. The methods would represent the behaviour of that type of thing and its properties would be the data associated to every particular instance, every object, of that type of thing.\nYou could think of a class as a data structure, like a dictionary, with some methods that act on the data stored in that dictionary. It would be something like this:\n\n\n\n\n\n\nSo, you could almost think of a class as syntactic sugar that bounds some functions to a data structure, like a dictionary. The data structure that holds the specific data of each object, like rectangle1 and rectangle2, in the class methods is represented by self. That is why, in Python, every standard class method has as a first argument self, the argument that represents the data for a particular object. In some languages, like in the old good Perl, this association of the methods to the data structure to create a class is explicit. In Perl they use the bless statement. They bless the data stored in a data structure with the methods/functions located in what they call a package, that is a kind of Perl module.\nBy the way, our Rectangle class has a print method, but in Python it would be better to name that method as str:\n\n\n\n\n\n\nThese kind of methods, that start and end with two underscores, in Python are called magic methods.\n\nAttributes: properties and methods\nFinnaly, you will hear about attributes. In Python we talk about methods, properties and attributes. Attributes are the sum of the properties and methods, so all that is accessed with the dot notation: “object.attribute”. In this regard you will also read about other terms like: [fields]. There is no consensus about the exact meaning of all these terms: attribute, field, property, and in different programming languages they tend to use them in sligtly different ways. But remember no matter the exact term used: classes have an interface comprised by data and behaviour.\nIf you want to access the list of attributes of an object, you can use the dir built-in function.\n\n\n\n\n\n\ndir returns a big list of attributes because Python, under the hood, adds a lot of functionality to any object. Moreover, there are quite a lot of methods whose names start and ends with two under scores, like: init, class, or name. These are known as special or magic methods.",
    "crumbs": [
      "Objects and classes"
    ]
  },
  {
    "objectID": "objects_and_classes.html#encapsulation",
    "href": "objects_and_classes.html#encapsulation",
    "title": "Object oriented programming",
    "section": "Encapsulation",
    "text": "Encapsulation\n\nClasses and modularity\nSo, classes we created by the fussion of data structures and methods that worked on those data structures. One could ask, if we can write our rectangle logic using a dict as a data structure and a couple of functions, are classes really necessary and, moreover, why bother? Well, classes are not really necessary. There are many languages, like C, that do not use classes at all, they do not even have the concept, and those languages are used to create huge and successfull software projects. For instance, the Linux kernel, that is mostly C, has more than 28 millions lines of code, and more than 20 thousand contributors.\nSo clases are not necessary, but they can be very convinient because they are even more modular than mere functions. By using classes we can isolate the different pieces that comprise the software even more effectively than with functions because they merge the data structure and the behaviour. And in that way the structure of the data becames a hidden detail implementation, it is not part of the interface anymore. In the function based rectangle implementation the data structure, in that case a dictionary, was part of the interface of the rectangle_print funtion, while in the print method of the Rectangle class the way in which the data is given to the method is not a user concern. For instance, we could reimplement the Rectangle class that stores the object data in a different way, but that wouldn’t need to alter the interface.\n\n\n\n\n\n\nIn this particular case, to maintain the same exact interface, we have created a private (more about this later) dictionary to hold the object data, _sides, and we have used the property decorator to provide the width and height properties that the previous implementation had.\nClasses are a way of approaching the question of how data and action, data structure and functions, relate. In the procedural approach data structures are part of the interface, whereas in the class they way in which the data is stored is mostly hidden, it is almost an implementation detail.\nThis tight relation between data and behaviour is known as encapsulation. The class interface is smaller than the combined interface of all the functions required to do the same job. So classes are convinient, among other reasons, because they allow to modularize the software projects more effectively that functions. This is one of the major appeals of the Object Oriented Programming approach, the modularization is deeper than in the procedural case. With the right design, Object Oriented Programs are easier to scale.\nYou can create huge projects based on the procedural paradigm, but to have a highly modularized project, you have to be very disciplined when defining and changing the data structures. For instance, you could collect all functions that work with a particular data structure in the same place, like in a file, a Python module. In that way if the data structure would had to be changed, the functions that should be modifed would all be collected together in the same file. This kind of procedural approach would be a limited kind of encapsulaiton and would have some of the benefits of the Object Oriented paradigm.\nLet’s see another example of how hidding the structure of the data helps with modularity. Imagine that we have implemented a Circle class.\n\n\n\n\n\n\nNow we are asked to add a feature related to ellipses and to avoid extra code we take advantage of the fact that circles are just a special kind of ellipses and we decide to reimplement our Circle class in a completely different way.\n\n\n\n\n\n\nWe have implemented Circle as a subclass of Ellipse. This is called: object inheritance. But this is not the most relevant part here. From the modularization point of view, the most important lines are the two last ones. The user of the Circle class, despite the complete reimplementation of the Circle class, has not changed anything at all in its code. This is what we mean by modularity. This code is modular, the programmers that build the Circle class and the ones that use it could be completely independent and the implementers could radically change their implementation, including the data structures that store the object data, without the users of that funcionality needing, in many cases, to change their code.\n\n\nPrivate and public attributes\nClasses can hide part of its data and methods from the rest of the program to create an even smaller interface, and the smaller the interface, the looser the conection between the code modules, and the more maintainable and extensible the code will be.\nOne way to create smaller interfaces is to limit the variables/properties made available to the class users. This is also part of the encapsulation provided by the object oriented approach, we can make variables private, available only to the class and not the class users. For instance, in our rectangle example we could make the width and height variables private, not available outside the class.\n\n\n\n\n\n\nThe only difference is that now the width and height properties are called _width and _private. In other programming languages they have ways of enforcing the distinction between private and public methods and properties, but that is not the case in Python. In Python everything is public, can be accessed, and privacy is a mere convention. Methods and properties whose names start with an underscore are supposed to be private, they should be only accessed by the class methods. That is not enforced by the language, but be aware that Python maintainers will asume that you understand and honor this convention and, thus, they will change these “private” attributes without any previous warning.\nThe main advantage of having private attributes is that they are only used in a limited part of the code, like within the class, and can not used by the rest of the code base. That means that when we need to change something related to a private attribute, the change will be limited to that class, and maybe, to their descendants (more about later). This is particularly useful in large projects where changes are inevitable. In contrast, in procedural programming, a change in any variable used by a function will require changes in several other parts, making it more complex and time-consuming to fix bugs and to functionalities. As a general rule, to guarantee a high level of modularity, make public as few attributes as possible.",
    "crumbs": [
      "Objects and classes"
    ]
  },
  {
    "objectID": "objects_and_classes.html#objects-store-state",
    "href": "objects_and_classes.html#objects-store-state",
    "title": "Object oriented programming",
    "section": "Objects store state",
    "text": "Objects store state\nSometimes it is necessary to keep track of a state, like the value of a variable, between function calls. In the procedural approach we could do it by storing the state in a variable that is passed every time to the function. Let’s imagine that we want to count how many times a function has been called, we could write something like this:\n\n\n\n\n\n\nThis would work, but to pass and return the num_times variable everytime to the function it is a bit cumbersome. Moreover, this variable might be only relevant to that function, so having the variable available outside the function scope is uncessary and it would be just a source of problems. Alternatively, we could use a global variable.\n\n\n\n\n\n\nThis is much more convinient and requires less code, but we are making use of a global variable to keep track of the state, the number of times that the function has been called, and global variables break modularity because they are avaible in all code base, any part of the code could alter them, and, thus, are prone to create maintainability problems.\nObjects provide a solution that it is both convenient and modular because it does not use global variables.\n\n\n\n\n\n\nNow the variable that we are using to store the state, number_of_times, is only available to the greeter objects.\nIn this case number_of_times variable is an object property, so it is not shared between objects, it will reflect only how many times the print_hello method has been called in a particular object.\n\n\n\n\n\n\nHowever, classes even allow us to create class level variables shared by all objects if we need to.\n\n\n\n\n\n\nBe careful with the class level variables because their scope is larger than the object variables, and a more limited scope facilitates code modularity.\nThis is another big advantage of the Object Oriented paradigm: it allows us to keep track of a state between calls in a very natural way without having to use global variables.",
    "crumbs": [
      "Objects and classes"
    ]
  },
  {
    "objectID": "objects_and_classes.html#abstraction",
    "href": "objects_and_classes.html#abstraction",
    "title": "Object oriented programming",
    "section": "Abstraction",
    "text": "Abstraction\nClasses facilitate code reuse by creating hierarchies of classes that share some of their behaviours by using inheritance. This is a feature that I do not usually need and that some languages with object oriented capabilities, like Rust, do not implement or do not encourage.\nAnother way to share behaviors between different clases is to just use the idea of a shared behaviour, that is, to have similar interfaces. In Python this kind of ideas are widely used. For instance, there are core pythonic ideas that are just interfaces, shared behaviours, like: file-objects, iterators, sequences or mappings. If you are interested in these ideas I recommend to you the Real Python tutorial on interfaces.",
    "crumbs": [
      "Objects and classes"
    ]
  },
  {
    "objectID": "objects_and_classes.html#procedural-vs-object-oriented",
    "href": "objects_and_classes.html#procedural-vs-object-oriented",
    "title": "Object oriented programming",
    "section": "Procedural vs object oriented",
    "text": "Procedural vs object oriented\nPython, as we have seen, allows us to write procedural and object oriented code. You can chose different approaches to solve different problems and you can combine them. That forces you to decide what to do in each occasion and there are no strict rules to follow, you will develop your style by reading and writting code.",
    "crumbs": [
      "Objects and classes"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "These notes are meant to reflect about how to organize the code, specially about how and when to structure the code in a procedural, object oriented or functional way. This is not a course on how to structure your code, but just an introduction to the ideas to have in mind when thinking about which approach to use to structure your code. I think that structuring the code is an art, a craft, that can only be adquired through practice and experience, especially with the experience of working with other good programmers, and it is a skill that is never completely mastered, but let’s hope that thinking about the motivations and tools involved one could develop this craft faster, and moreover, that one would learn about the importance of writting nicely structured code instead of an unmaintainalbe mess.\nIt is a common mistake, specially among beginers, to think that our aim when we write computer code is to create fast and memory efficient, very performant, programs. Of course we’d like our programs to run faster, but that’s not our only, or main, goal, otherwise every program would be writen in assembly, a language capable of squeezing out every bit of computing power out of our machines. However, few programmers write in assembly.\nWhen one starts to code spends a lot of time thinking about how to implement the algorithms required to accomplish the task at hand, but as you gain experience in your programming carreer you focus your attention more and more in the structure of your code. Unstructured, spaghetti, code, could still be the option if you just need a 20 line script to solve a specific task, but for anything more complex than that you will realize that you need to think on the structure.\nPerformance is important, but programmers also have other aims like writting:\n\na working product before the universe ends, and, even better, before their managers and clients run out of patience.\nrealiable code that can be trusted.\nmaintable code in which bugs are easily located and fixed, and new features can be easily added.\nportable programs that can be used in different hardwares and scenarios.\n\nReadability and modularity are the two main ways to accomplish these goals.\nWe have to divide our programming projects into small modules. Here, by module, I just mean a program part, not a Python module, these modules can be packages, modules, classes, functions, data structures, etc. Big problems are daunting tasks and we usually solve them by dividing them into many small, or even trivial, tasks. Since the first days of coding, programmers have been thinking about how to accomplish this division into parts, in different ways of how to structure the code, in different programming paradigms.\nAnother advantage of creating small modules with clearly defined reponsabilities, like sorting a list of items or storing or loading data form disk, is that we can reuse them several times inside a project or even between projects. Programming, in practice, consists mainly in mixing previous ideas, in the form of libraries, packages or modules, to create the code that solve our current problem. Computer programs are akin to lego constructions. For programmers, it would be impossible to create even a relatively simple program from scratch, but this modularity allow them to create even complex software in little time. In fact, the only way to create a medium to large software project is to split its functionality in parts.\nThe functionality of these small parts is also easier to define precisely, to specify, and easier to check. Moreover, we could trust reused parts, that have already been tested in previous projects, than brand new ones, that are likely to include unknown bugs. Thus, programs created out of these parts will be more reliable. In fact, a fundamental good programming practice is to test the functionality of our code, and this is much easier to do if we divide our program into modules.\nMedium and large programs can be only created and maintained by teams, they are not writen by lone programers. Thus, readability is a fundamental aspect. Code should be clear and easily understandable, readibility is paramount, and modularity is key in this regard. Remember the wisdom of the Zen of Python: “Readability counts”. If the software is relevant we will have to fix bugs and add functionality in the future. Even if we are working alone we have to take into account that our future self, in six months, won’t be able to understand the code unless is clear, and modularity facilitates this task.\nSo, we have to structure our code, but there are different ways of creating this structure. For instance, we could use a procedural, object oriented or functional approach. The aim of these notes is to help us reflect on the advantages and limitations of these approaches.\nThere are other texts that take a theoretical approach, but here we aim to be practical. One can think, for instance abouth functional programming, in a very theoretical way, but our notes on the functional approach won’t be that. I write code in Python, a multiparadigm language. I can choose to use a procedural, object oriented or functional approach, and I can mix these ways of structuring the code in the same project. So, which is the best way to do it? We won’t be able to provide absolute rules to answer this question, nobody does, but let’s hope that these lines help us to think about it in a more productive way.\nIf you have just started coding, I guess that all this ideas might sound very abstract, but, maybe, reading about these paradigms, these approaches, might, at least, convince you that you have to care about the structure of your code, and that, with time, you’ll have to improve on this skill.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Introduction",
    "section": "",
    "text": "These notes are meant to reflect about how to organize the code, specially about how and when to structure the code in a procedural, object oriented or functional way. This is not a course on how to structure your code, but just an introduction to the ideas to have in mind when thinking about which approach to use to structure your code. I think that structuring the code is an art, a craft, that can only be adquired through practice and experience, especially with the experience of working with other good programmers, and it is a skill that is never completely mastered, but let’s hope that thinking about the motivations and tools involved one could develop this craft faster, and moreover, that one would learn about the importance of writting nicely structured code instead of an unmaintainalbe mess.\nIt is a common mistake, specially among beginers, to think that our aim when we write computer code is to create fast and memory efficient, very performant, programs. Of course we’d like our programs to run faster, but that’s not our only, or main, goal, otherwise every program would be writen in assembly, a language capable of squeezing out every bit of computing power out of our machines. However, few programmers write in assembly.\nWhen one starts to code spends a lot of time thinking about how to implement the algorithms required to accomplish the task at hand, but as you gain experience in your programming carreer you focus your attention more and more in the structure of your code. Unstructured, spaghetti, code, could still be the option if you just need a 20 line script to solve a specific task, but for anything more complex than that you will realize that you need to think on the structure.\nPerformance is important, but programmers also have other aims like writting:\n\na working product before the universe ends, and, even better, before their managers and clients run out of patience.\nrealiable code that can be trusted.\nmaintable code in which bugs are easily located and fixed, and new features can be easily added.\nportable programs that can be used in different hardwares and scenarios.\n\nReadability and modularity are the two main ways to accomplish these goals.\nWe have to divide our programming projects into small modules. Here, by module, I just mean a program part, not a Python module, these modules can be packages, modules, classes, functions, data structures, etc. Big problems are daunting tasks and we usually solve them by dividing them into many small, or even trivial, tasks. Since the first days of coding, programmers have been thinking about how to accomplish this division into parts, in different ways of how to structure the code, in different programming paradigms.\nAnother advantage of creating small modules with clearly defined reponsabilities, like sorting a list of items or storing or loading data form disk, is that we can reuse them several times inside a project or even between projects. Programming, in practice, consists mainly in mixing previous ideas, in the form of libraries, packages or modules, to create the code that solve our current problem. Computer programs are akin to lego constructions. For programmers, it would be impossible to create even a relatively simple program from scratch, but this modularity allow them to create even complex software in little time. In fact, the only way to create a medium to large software project is to split its functionality in parts.\nThe functionality of these small parts is also easier to define precisely, to specify, and easier to check. Moreover, we could trust reused parts, that have already been tested in previous projects, than brand new ones, that are likely to include unknown bugs. Thus, programs created out of these parts will be more reliable. In fact, a fundamental good programming practice is to test the functionality of our code, and this is much easier to do if we divide our program into modules.\nMedium and large programs can be only created and maintained by teams, they are not writen by lone programers. Thus, readability is a fundamental aspect. Code should be clear and easily understandable, readibility is paramount, and modularity is key in this regard. Remember the wisdom of the Zen of Python: “Readability counts”. If the software is relevant we will have to fix bugs and add functionality in the future. Even if we are working alone we have to take into account that our future self, in six months, won’t be able to understand the code unless is clear, and modularity facilitates this task.\nSo, we have to structure our code, but there are different ways of creating this structure. For instance, we could use a procedural, object oriented or functional approach. The aim of these notes is to help us reflect on the advantages and limitations of these approaches.\nThere are other texts that take a theoretical approach, but here we aim to be practical. One can think, for instance abouth functional programming, in a very theoretical way, but our notes on the functional approach won’t be that. I write code in Python, a multiparadigm language. I can choose to use a procedural, object oriented or functional approach, and I can mix these ways of structuring the code in the same project. So, which is the best way to do it? We won’t be able to provide absolute rules to answer this question, nobody does, but let’s hope that these lines help us to think about it in a more productive way.\nIf you have just started coding, I guess that all this ideas might sound very abstract, but, maybe, reading about these paradigms, these approaches, might, at least, convince you that you have to care about the structure of your code, and that, with time, you’ll have to improve on this skill.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "Introduction",
    "section": "Licence",
    "text": "Licence\nThis content is released under a Creative Commons BY licence.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "procedural.html",
    "href": "procedural.html",
    "title": "Procedural programming",
    "section": "",
    "text": "At the begining, when computers were simple, when programs were very small and performed just one task programmers didn’t need to worry about dividing the code in modules/parts/sections that dealt with different tasks. However, very soon computers became more powerful, programs grew and code became unwieldy and the spaghetti code was born. Programmers thought about how to solve the issue, on how to unravel the spaghetti, and they came with the idea that they had to divide the code into small subtasks. This allows for:\n\nThe reuse of these small pieces of functionality.\nThe division of labor in teams of programmers in which different people can implement and maintain different parts of the code.\nThe testing of the functionality of every piece of code. If every module has a well defined task to do, we can test if that code is doing what is supposed to be doing.\n\n\n\n\nSpaghetti vs structured\n\n\nIf you are writting a small script that performs a just one very well defined and small task, it might be OK not to structure your code. But for anything else, thinking about the structure is one of the most important programming tasks; and the main question to answer is: how do I divide this code into pieces that:\n\nperform only one task\nhave access only to the data that they require to complete the task\nhave a well defined interface\n\nOf course, not all programmers are experienced and disciplined and lots of code is unstructured, an entangle mess. Spaghetti code might work, but it is unmaintainable: bugs are difficult to fix, features impossible to add, and new programmers unfamiliar with the code will have a hard time working with it.\nFortunately programmers are resourceful, and very soon they realized that the key to maintainable code was to divide it in small pieces that performed a well defined task and that communicated with the rest of the program only through its declared interface. Different programming paradigms have been proprosed to help structuring the code, like Object Oriented Programming (OOP) or Functional Programming, but the most basic one, and a very used one, is Procedural Programing.",
    "crumbs": [
      "Procedural"
    ]
  },
  {
    "objectID": "procedural.html#it-all-started-with-the-spaghetti",
    "href": "procedural.html#it-all-started-with-the-spaghetti",
    "title": "Procedural programming",
    "section": "",
    "text": "At the begining, when computers were simple, when programs were very small and performed just one task programmers didn’t need to worry about dividing the code in modules/parts/sections that dealt with different tasks. However, very soon computers became more powerful, programs grew and code became unwieldy and the spaghetti code was born. Programmers thought about how to solve the issue, on how to unravel the spaghetti, and they came with the idea that they had to divide the code into small subtasks. This allows for:\n\nThe reuse of these small pieces of functionality.\nThe division of labor in teams of programmers in which different people can implement and maintain different parts of the code.\nThe testing of the functionality of every piece of code. If every module has a well defined task to do, we can test if that code is doing what is supposed to be doing.\n\n\n\n\nSpaghetti vs structured\n\n\nIf you are writting a small script that performs a just one very well defined and small task, it might be OK not to structure your code. But for anything else, thinking about the structure is one of the most important programming tasks; and the main question to answer is: how do I divide this code into pieces that:\n\nperform only one task\nhave access only to the data that they require to complete the task\nhave a well defined interface\n\nOf course, not all programmers are experienced and disciplined and lots of code is unstructured, an entangle mess. Spaghetti code might work, but it is unmaintainable: bugs are difficult to fix, features impossible to add, and new programmers unfamiliar with the code will have a hard time working with it.\nFortunately programmers are resourceful, and very soon they realized that the key to maintainable code was to divide it in small pieces that performed a well defined task and that communicated with the rest of the program only through its declared interface. Different programming paradigms have been proprosed to help structuring the code, like Object Oriented Programming (OOP) or Functional Programming, but the most basic one, and a very used one, is Procedural Programing.",
    "crumbs": [
      "Procedural"
    ]
  },
  {
    "objectID": "procedural.html#functions-to-disentangle-the-spaghetti",
    "href": "procedural.html#functions-to-disentangle-the-spaghetti",
    "title": "Procedural programming",
    "section": "Functions to disentangle the spaghetti",
    "text": "Functions to disentangle the spaghetti\nProgrammers thought about how to create these subtasks, these small pieces of functionallity, and they created the idea of the function. By the way, functions are also known as procedures, subroutines and many other, more or less, synonymous terms, but we are just going to use the term function. They are the key tool used to structure the code, they are the fundamental building block in all the main programming paradimgs: Procedural, Object Oriented and Functional Programming.\n\nFunctions are isolated blocks of code\nA function is a named section of a program, a block of code, a sequence of instructions grouped under a single name, that performs a specific task and that can be invoked, called, by other parts of the program to carry out that task. In Python functions are defined by using the def statement.\n\n\n\n\n\n\nA function is a somewhat isolated block of code, a box with some inputs and some outputs. They are somewhat similar to a mathematical function, they might take some inputs, that could be numbers of any other kind of data, they do some calculations, some transformations, and they might return a result.\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    subgraph call[function call]\n        call_[\"call_circle_area(3)\"]\n        variable_passed[\"variable passed: 3\"]\n        variable_returned[\"return variable stored in variable: circle_area\"]\n    end\n\n    subgraph function[function calc_circle_area]\n        subgraph implementation_[\"internal implementation\"]\n            implementation[area = 3.14 * radius**2]\n        end\n        subgraph interface[\"interface\"]\n            input[input arguments: radius]\n            output[output: return area]\n        end\n    end\n    output ---&gt; variable_returned\n    variable_passed ---&gt; input\n\n\n\n\n\n\nThe function:\n\nmight take some data into the function\nperforms an action\nmight return some data out of the function\n\nIt is useful to think about the function as an action carried out on some data. Usually the data is a thing, like a cicle, and the function is an action performed on that thing, like calculting an area. Take that into account when naming the functions, they are actions and they take data related to things, nouns. A function name like “calc_circle_area()” reflects the action, a name like “circle_area()” does not.\nThe function can be divided in:\n\nan interface: the part of the function that interacts, interfaces, with the rest of the program\nan implementation: the details about how the action is carried out\n\nA function can be thought as as a lego piece that has a defined shape and that we could use in our projects every time that we need that particular shape.\n\n\n\nFunctions are the fundamental bricks\n\n\nThe interface of the function is its shape, everytime that we need to perform an action on a piece of data we can use that function, that block of code, in the same way.\nWhen thinking about the program structure, it is useful to fix our attention of the interfaces of the different parts of the program, on the shapes of the different blocks, because that is how the whole program will fit together, through its interfaces. The implementation of each part could be regarded almost as a detail. For instance, we could change the implementation the previous function without changing its interface.\n\n\n\n\n\n\nAn interface is a kind of contract, we are committing ourselves to providing a functionality that will be served by that particular interface, and as long as the caller continues using the same interface the function will continue honoring the contract, providing its functionality.\n\n\nThe advantages of modularity\nThis is one of the big advantages of the procedural programming, we can divide the program into smaller, and somewhat independent pieces of code, because we have limited the interaction between different parts of the program to their interfaces. We have turned a big piece of code into a collection of small interacting modules, a plate of spaghetti into a lego construction. This modularity is key and it helps with:\n\nUnderstanding the code: it is easier to understand little pieces that have well defined responsabilities than a huge blocks of code. It is easier to understand how a lego construction works than a plate of spaghetti. New programers, or even programmers already familiar with the code, will have a better time, a lower cognitive load, and will need less time understanding what the program is doing and how is doing it.\nBug fixing: it is much easier to locate which part of the code is responsible for a particular bug, like the calculus of the circle area if the functionality of the program is divided into small pieces. If an error occurs in a program organized with functions, a developer can locate and correct the error more quickly than in a poorly organized code.\nTesting: it is possible to check if a block of code is honoring its interface, because it now has an interface, a contract, to honor.\nExtendability: new functionalities will be also easier to create. It is much easier to add new pieces to a lego construction than to a mess of spaghetti.\n\n\n\nCode reuse\nFunctions allow us to structure the code in parts, they enable breaking down a program into smaller, more manageable, modules, and, in that way, we can break a complex problem into a series of simple tasks. Imagine that we have a program that calculates the area of a rectangle.\n\n\n\n\n\n\nThis program accomplishes its task, but if we want to calculate the area for two rectangles we would have to repeat the same code twice.\n\n\n\n\n\n\nIn programming a good rule of thumb is: Don’t Repeat Yourself, this is the DRY principle. Imagine that now we want to change the way in which the result is printed, for instance because we want to write the result into a file; we would have to rewrite every instance of the print that we have in our program.\n\n\n\n\n\n\nHowever, if we would had written our program using a function, we would had avoided repeating the code in the first place. We are reusing the code, and that is a nice principle to have in mind when we are programming.\n\n\n\n\n\n\nCode reuse, for instance, eases the implementation of new features. Imagine that now we want to write the result into a file instead of printing it in the console. With this new structure we would just need to change one function and the corresponding function calls and not like before, that we had to change every instance of the duplicated code.\n\n\n\n\n\n\nIn this case we have changed the function and the function calls (because we have to include the file object) to that function.\n\n\nOne function, one task\nEven better, we could structure the program by splitting the tasks carried out by the current function, calculating the area and printing the result, into two functions, one that calculates the area and another one that prints the result.\n\n\n\n\n\n\nThis change might seem small, but it has several advantages:\n\nThe program parts are now smaller and easier to understand and to test\nWe can calculate areas without printing them and we could print them without calculating them\nWe can create different printing functions, like one for printing into a file and another one for printing in the console.\nDifferent aspects of the program, like the math operations and the output could be taken care by different people or teams of programers. This is not important for this small program, but it might be critical for larger ones.",
    "crumbs": [
      "Procedural"
    ]
  },
  {
    "objectID": "procedural.html#scope",
    "href": "procedural.html#scope",
    "title": "Procedural programming",
    "section": "Scope",
    "text": "Scope\nTo understand what do we mean when we say that we pass some data to a function we need to understand the concept of the scope.\nWhen we are programming we store and access data in memory. As we have seen, we refer to the data stored in memory by using variables. We could think that those variables, once they are created, are available in every part of our program. If you would used that approach when you tried to build a program with more than a few lines of code, it would become very difficult to track which part of the program had changed a variable. So maintining those large programs would be very difficult.\nFunctions do not only structure the code in logical blocks, but they also limit the data that every one of those blocks can access. Functions can use:\n\nthe variables that are defined inside them.\nthe arguments that we pass to them.\n\nWe say that functions define a scope, an area of the program in which certain variables can be accessed. In a computer program not all data is available to every part of the code. The scope defines where in the code a variable is available, and functions define their own scope. The code inside a function has its own variables, and those are not shared between functions or between the function and the rest of the code.\nFor instance, the variables that are defined inside a function are not available outside of the function.\n\n\n\n\n\n\nWe say that the variables defined in the function are in the function scope, that means that they are not available ouside of the function.\n\n\n\n\n\n\nWe get a “‘name’ is not defined error” because the variable name was created inside the say_hello function, so in the say_hello scope, and is not available outside. A variable can only be used when is in the current scope. It is said that the function has a local scope in which its variables are available.\nTo use a value inside a function, usually, we pass the variable to the function.\nSchema with the scope of a function call:\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    subgraph def[\"def calc_area(width, height):\"]\n        subgraph func_scope[\"Function scope\"]\n            subgraph return\n               ret[\"return area\"]\n            end\n            subgraph in[\"function variables\"]\n               var[\"area = width * height\"]\n            end\n            subgraph arguments\n               width\n               height\n            end\n        end\n    end\n    subgraph result[\"result = calc_area(2, 3)\"]\n        subgraph caller[\"Caller scope\"]\n            subgraph result_[\" \"]\n               result__[\"result =\"]\n            end\n            subgraph funccall[\"Function call\"]\n               call1[\"calc_area(2, 3)\"]\n            end\n        end\n    end\n    return ---&gt; result__\n    call1 ---&gt; arguments\n\n\n\n\n\n\nA variable points to some data stored in memory. Strictly speaking the variable belongs to a scope, the data pointed by the variable does not. For instance, if we store an object in memory, like the value 2, that object does not belong to a scope, the variables that might point to it do.\n\n\n\n\n\n\n\nGlobal scope\nBe careful because Python also has a global scope, and if you create the variable outside the function it will be available inside. We can use the variables defined in the global scope inside any function.\n\n\n\n\n\n\nIn this case the variable name has been created in the global scope, it is a global variable available everywhere. In general, avoid creating global variables, specially if they are not inmutable constants. As a general rule, the use of the global scope is discouraged, try not to use it. If you think you need a global variable, think twice, in most cases is better not to use them.\nHere’s a tip for the future you, to keep states it might be much better to use objects, instances of a class, than global variables.\nJust remember, try very hard not to use global varibles, although you can allow some exceptions with some inmutable ones used for global configurations. (By the way, if you follow the PEP8 style guide, as you should, contants defined in the global scope are written with all capital letters.) It is common to use this kind of global variables, inmutables and related to configuration, and, by convention, in Python, people name them using all-caps variable names.\n\n\n\n\n\n\nHowever, altering variables that belong to the global scope is discuraged and trying to do so can end up in unexpected behaviours.\n\n\n\n\n\n\nIf you try to change a global inmutable variable you might get an error.\n\n\n\n\n\n\nPython allows you to modify a global variable, but you have to explicitely ask for it by using the global statement.\n\n\n\n\n\n\nThe global statement is a nice remainder of the problem of altering the global state.\nIn Python we can also alter the global state, the variables that belong to the global scope, without using the global statement. We can modify mutable objects referenced by variables that belong to the global scope.\n\n\n\n\n\n\nIn general, try not to abuse of the global scope. Functions were desing to modify only its scope and having side effects goes agaist the modularity achived by having functions in the first place. If you abuse of the global scope:\n\nProceed at your own risk.\nBe aware, there might be dragons ahead.\nYou have been warned.\n\nYou can read more about scopes and namespaces in the Python official documentation.\n\n\nPassing data to a function, function arguments\nSo, when the function requires some data to carry an action, we should pass that data explictly to the function. For instance, if we want a function to print a personalized greeting, it could need the name of the person.\n\n\n\n\n\n\n\n\nreturn\nScopes have also to be taken into account when getting a result out of the function.\n\n\n\n\n\n\nIf we want to get data out of the function we use the return statement. Let’s see how we can return data to the caller.\n\n\n\n\n\n\nWe use the return statement to return a value generated in the function to the caller. Again, like in the arguments passed to the function, the caller will receive a new reference to the value stored in memory that can assign to a new variable. return is used to move a result in memory between scopes. For instance, in the previous example there is a variable, inside the function, named area, but in the first call we store the reference in a variable named result. area and result are two variables, two references to the same value stored in memory, but they are variables that belong to different scopes. In this case area belongs to the scope of the calc_rect_area function and result to the global scope.",
    "crumbs": [
      "Procedural"
    ]
  },
  {
    "objectID": "procedural.html#argument-and-return-types",
    "href": "procedural.html#argument-and-return-types",
    "title": "Procedural programming",
    "section": "Argument and return types",
    "text": "Argument and return types\nPython is a dynamic language, it does not require to defined the types of the arguments and return values, and, by default, does not enforce those types even when they are defined. The type annotations are meant as a way of documenting the code.\nThere are typing tools, like mypy that can be used to enforce the use of the types, but they are not part of the language proper.",
    "crumbs": [
      "Procedural"
    ]
  },
  {
    "objectID": "procedural.html#the-function-interface",
    "href": "procedural.html#the-function-interface",
    "title": "Procedural programming",
    "section": "The function interface",
    "text": "The function interface\nNow that we have talked about how to define functions, and how to pass and get data from them, we can deliniate what the function interface is. Remember, when thinking about a function, or any other form of modularizing the code, of dividing it in pieces, take into accounts two aspects:\n\nthe interface: how the function interacts with the rest of the program\nthe implementation: how the task is carried out\n\nFor the structure of the program interfaces are more important than implementations, because if you change an implementation, for instance to speed it up or to fix a bug, the rest of the program will be unafected as long as you keep the interface. Think of the interface as a promise done to the rest of the program, as a contract that the function will honor. Thus, for the rest of the program, the implementation is just a detail, what matters is how to interact with that piece of the code. The program is a complex machine build with small, and hopefully understandable, pieces, and the interface is the shape of each piece.\nWe could split the interface in two: the explicit or interface proper, and the implicit interface. We could also call to these two parts: interface and side effects.\nThe interface proper is comprised by:\n\nthe function name, and possible the namespace in which that name is found\nthe arguments accepted by the function as well as its types\nthe returned values and its types\n\nA more suttle part of the interface, the implicit interface, or the side effects, an effect other than reading the value of the function arguments and returning the intended result. Side effects are interactions of the function with the rest of the program that are not explicitly declared like:\n\nany modification of the state of the objects passed to the function that are not clearly stated in the interface and, thus, not expected by the user.\nany modification to the mutable objects passed to the function not clearly estated\nany modification of the global state, like changing the value of a global variable\nany use of the global scope, like the reading of a global variable\n\nThe interface proper is the stated contract that the function explicitely declares to follow and its at the base of the software modularity. Side effects are a modularity violation and a throw back to the spaghetti code, to an unmaintainable mess. (Although, in some cases these side effects can be useful, or even completely necesary).\n\nName and namespace\nThe function name is a critical part of the function interface, if we would change it, the rest of the code that uses that function would have to be changed.\nThe namespace, where the function can be found, is also important. For instance, in Python the sqrt function is located in the math module of the standard library, so to use it we have to import it from there.\n\n\n\n\n\n\nIf the Python developers were to change the location of the sqrt function, we would have to change our code accordingly. By the way, in the Python standard library there is a different sqrt function with a different interface, a function that return complex numbers instead of floats, and we differenciate between these two functions because they are imported from different namespaces, from different modules.\n\n\n\n\n\n\n\n\nArguments\nThe arguments accepted by the function, as well as its types, are also part of the interface, if we were to change the arguments required or accepted, we might have to change the rest of the code, the parts of the program that make calls to the modified function.\n\n\nReturned values\nReturned values and types are also part of the interface, if we change what we return we will have to alter the calls to the function.\nBy the way, I think that it is not a very good practice to change the number or type of the values returned depending on the function call. Imagine that we did a function that returned either a float or a complex number depending on the input.\n\n\n\n\n\n\nThis is a well defined interface, but the caller will have to check what is getting from the function.\nA better solution would be to make the caller/user of the function to deal with the two options, as the standard library sqrts functions do.\n\n\n\n\n\n\nNow the caller is explicitly aware of the two possible types and will have to decide how to deal the situation.\nWe have the same problem when we choose to return None when the function fails to calculate the result.\n\n\n\n\n\n\nIn this case it’d be better to just let the error be raised, like the standard library sqrt function does. In that way the caller we’ll be aware that a problem happened, and will have to deal the the error only when it needs to, and not in every call in the call stack.\n\n\nObject state change\nA function could change the state of an object passed as an argument. For instance, imagine that you are reading from a file and that you pass the file object to a function, that function could change the state of the file object, for instance by consuming from the file or by closing it.\n\n\n\n\n\n\nAfter calling to the different functions the behaviour of the program will be quite different, so the change in the state of the file object is a side effect, a implicit part of the function interface. It is always a good policy to informe to the caller/user of the function about these changes of state by making them explici t. ### Gobal variables\nAnother kind of side effect is to affect the global scope. This is highly discuraged, there is a global scope and many times it is reasonable to use it to read, for instance, inmutable configuration variables. But altering a variable in the global state takes us back to the path of unmaintanable spaghetti code.\nIn Python the global scope is frequently used to store configuration constants.\nAltering global variables makes the progam less modular because although the change of these variable could be considered part of the interface of the function, it is not an explicit part, it is not declared as an argument or as a return. So, by modifying global variables we get code that is more spaghetti like, and that so the program will be less maintainable.\nIf you think that you need to alter the global state, think twice, because, in general, this is a very bad idea. If after thinking it carefully you still think you need to do it, think it again. There is another mechanism to store states between funcion calls that respects the modularity: classes and objects. Objects are modular and they allow us to store states between calls. That is one of the big difference between the procedural and the object oriented approach.\n\n\nValue change of mutable objects\nIn general, we could pass data to a function if two different ways by:\n\ncopying it\nusing a reference or a pointer\n\nIn the first case we copy the value. Imagine that we were passing a variable that holds the integer 2. We would pass that data to the function by creating a copy of that number in a different part of the memory and, thus, the variable inside the function would reference to a different 2 than the variable outside the function.\nIn the second case both variables, the one inside the function and the ones outside, would end up referencing the same value, the same 2. In some languages, like C or Rust one can chose how to proceed, do we want to copy the data or to create a reference or a pointer to it, and that is made explicit in the function interface.\nOne of the Python objectives was to be simple, and that is why, maybe, his creator chose to avoid this complexty and to make all arguments passings to any function by reference. Moreover, in Python all variables are always references.\n\n\n\n\n\n\n\nWe have created a text string (“Jane”). That means that Python has created and stored a object of type str in memory.\n\n\n\n\n\n\nflowchart TB\n    subgraph main [ ]\n    person:::invisible\n    end\n    subgraph say [ ]\n    name:::invisible\n    end\n    Memory:::memory\n    subgraph Memory\n    Jane[\"'Jane'\"]\n    end\n    person --&gt; Jane\n    name --&gt; Jane\n    classDef variable fill:#f96\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n    linkStyle 0,1 stroke-width:0px\n\n\n\n\n\n\n\nWe have assigned the variable person to that string, so now person refers to that str object stored in memory.\n\n\n\n\n\n\nflowchart TB\n    subgraph main [global scope]\n    person\n    end\n    subgraph say [ ]\n    name:::invisible\n    end\n    Memory:::memory\n    subgraph Memory\n    Jane[\"'Jane'\"]:::variable\n    end\n    person --&gt; Jane\n    name --&gt; Jane\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n    linkStyle 1 stroke-width:0px\n\n\n\n\n\n\n\nWhen we call the function we pass the reference of the object, the variable person, to the function.\nThe function receives the reference to the str object and assigns to it a new reference, in this case called name. It is very important to understand that although the object is the same, the “Jane” string, we have created a new reference to it, the new variable name.\n\n\n\n\n\n\nflowchart TB\n    subgraph main [global scope]\n    person\n    end\n    subgraph say [say_hello scope]\n    name\n    end\n    Memory:::memory\n    subgraph Memory\n    Jane[\"'Jane'\"]\n    end\n    person --&gt; Jane\n    name --&gt; Jane\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n\n\n\n\n\n\nFor inmutable types having several references to the same object is not a problem at all because even if different variables hold references to the same object, none of them could change its value, but with mutable data types we have a problem. For instance, a function could change a list, that has been passed to it by a caller, by appending values to it without the caller awarenes. So, in Python mutable objects could be altered inside any function and that is part of the interface, but an implicit part.\nTry to guess what will be the result of running the following code:\n\n\n\n\n\n\nGive x a value in order the get the result to be 10. Should x be 4 or 6?\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith lists the behaviour seems different.\n\n\n\n\n\n\nWhy do we get these different results?\nLet’s think about what is going on.\n\na = \"hello\"\n\n\n\n\n\n\nflowchart TB\n    subgraph variables\n    a\n    b:::invisible\n    end\n    Memory:::memory\n    subgraph Memory\n    hello1[\"'hello'\"]\n    hello2[\"'HELLO'\"]:::invisible\n    end\n    a --&gt; hello1\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n\n\n\n\n\n\n\n# a.upper() creates a new string, it does not modify\n# the original string that remains intact in memory\n# and now b refers to the new string \"HELLO\"\nb = a.upper()\n\n\n\n\n\n\nflowchart TB\n    subgraph variables\n    a\n    b\n    end\n    Memory:::memory\n    subgraph Memory\n    hello1[\"'hello'\"]\n    hello2[\"'HELLO'\"]:::invisible\n    end\n    a --&gt; hello1\n    b --&gt; hello1\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n\n\n\n\n\n\n\nb = a\n\n\n\n\n\n\nflowchart TB\n    subgraph variables\n    a\n    b\n    end\n    Memory:::memory\n    subgraph Memory\n    hello1[\"'hello'\"]\n    hello2[\"'HELLO'\"]\n    end\n    a --&gt; hello1\n    b --&gt; hello2\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n\n\n\n\n\n\nWith mutable objects, like lists, the result will be different.\n\na = [\"hello\", \"Jane\"]\n\n\n\n\n\n\nflowchart TB\n    subgraph variables\n    a\n    b:::invisible\n    end\n    Memory:::memory\n    subgraph Memory\n    hello1[\"['hello', 'Jane']\"]\n    end\n    a --&gt; hello1\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n\n\n\n\n\n\n\nb = a\n\n\n\n\n\n\nflowchart TB\n    subgraph variables\n    a\n    b\n    end\n    Memory:::memory\n    subgraph Memory\n    hello1[\"['hello', 'Jane']\"]\n    end\n    a --&gt; hello1\n    b --&gt; hello1\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n\n\n\n\n\n\n\n# We are modifying the original list\nb[0] = b[0].upper()\n\n# b[0] refers to the string \"hello\"\n# b[0].upper() creates a new string in memory \"HELLO\"\n# so b[0] = b[0].upper() is equivalent to\nb[0] = \"HELLO\"\n# We are asking to the list refered by b, the same list that a refers to,\n# to change its first member from \"hello\" to \"HELLO\"\n# So we get a modified list [\"HELLO\"] and both a and b refer still to this list\n# that is in fact the same original list, that is has changed its first member\n\n\n\n\n\n\nflowchart TB\n    subgraph variables\n    a\n    b\n    end\n    Memory:::memory\n    subgraph Memory\n    hello1[\"['HELLO', 'Jane']\"]\n    end\n    a --&gt; hello1\n    b --&gt; hello1\n    classDef invisible opacity:0%\n    classDef memory fill:#ccc\n\n\n\n\n\n\nThis is an aspect that varies from language to language. If you study a different programming language you will need to understand if the variables are ment to be values, pointers or references. In Python they are always references. You can read a Real Python tutorial about how Python pass by reference.\nChanging inside the function a mutable object that have been passed to it without warning the function user is a common source of bugs and problems. This is not a good practice, try to avoid it! The previous code could be written to avoid this problem.\n\n\n\n\n\n\nOne way to make the change of the object inside the function, more or less, explicit is not to return the object. That is why lists methods like append, extend or sort do not return the list. The callers are made aware that they are not getting a new list and the original one is intact, no, the list that they sent to the function is changed. Well, in this case, these are not, strictly speaking, functions, but object methods, but they still could return a reference to the object. Their interface could be more similiar to the upper, lower or strip methods of the str class that do return a new str (in this case because the str objects are inmutable, so unlike the lists they can not be modified and so upper cannot modify the original object, but can only create a new one that has to be returned).",
    "crumbs": [
      "Procedural"
    ]
  },
  {
    "objectID": "procedural.html#testing-and-modularity",
    "href": "procedural.html#testing-and-modularity",
    "title": "Procedural programming",
    "section": "Testing and modularity",
    "text": "Testing and modularity\nHaving isolated pieces of functionality and an interface defined for each piece makes possible that we test the complience of each piece to its interface. Is this piece honoring its interface/contract?\nIn spaghetti code we could test if the overall complex functionality of the program is working, but if we have a modular code base testing becames much more useful because we can test that each piece works, and the task carried out by every small unit is simpler and thus finding and fixing bugs is easier. Moreover, if we decide to change the implementation of, for instance, one function, but the test is still working we can be confident, although not completely sure, that the rest of the program will sill work.\nLet’s show how a test would work.\n\n\n\n\n\n\nTesting is a huge topic in and of itself and we won’t cover it here, but read something about unit testing. Be aware that in Python there is a module called unittest in the standard library that helps with creating tests (more about the unittest module in Real Python), but that there is another testing library: pytest. pytest is not included in the standard library, but is more modern and much more capable that unittest, and it is also very popular. You can read about pytest in Real Python or in the pytest book.",
    "crumbs": [
      "Procedural"
    ]
  },
  {
    "objectID": "functional_programming.html",
    "href": "functional_programming.html",
    "title": "Functional programming",
    "section": "",
    "text": "Another way in which we can approach the structure of a program is Functional Programming.\nOne could be tempted to think that Functional Programming is the paradimg that uses functions, but that would be a mistake. As we have already seen, functions are the key concept in the Procedural approach and functions, althought they are called methods, are a key component of the classes used in the Object Oriented approach. It is called Functional Programming, because in this approach functions are used in new ways, they can, for instance, be arguments passed to other functions.\nFunctional Programming is normaly explanied in very theoretical terms. This kind of theoretical explanation might have its uses, but you won’t find it here. In my day to day work I use functional programming concepts all the time, but always motivated by a practical need. This functional approach is especially useful when dealing with big data sets, and that it why I use it.\nLet’s do an example. Imagine that we want to sum all the numbers from 1 to 9. We could do it using a procedural approach with the following code.\nOr we could solve it using a functional approach.",
    "crumbs": [
      "Functional programming"
    ]
  },
  {
    "objectID": "functional_programming.html#iterators",
    "href": "functional_programming.html#iterators",
    "title": "Functional programming",
    "section": "Iterators",
    "text": "Iterators\n\nIterators and iterables\nTo sum some numbers, for instance the first 1000 integers, we don’t need to create a list to hold them, we only need to get those numbers one after the other, one at a time. In Python that’s the difference between a sequence and an iterator.\nLists or strings are examples of sequences, they are objects that:\n\nallow for random access, we can access every item by its position in the sequence\nhave a length, they can return the number of items that they contain\n\nWe could use those properties to get a list of numbers summed.\n\n\n\n\n\n\nBut, we could accomplish the same goal, with much less. We don’t need the items to be ordered, or to know the total number of items or, even, to have all the numbers in memory at the same time; we just need access to each element, one at a time, that’s all.\n\n\n\n\n\n\nThis time we have used range. range objects don’t hold the number in memory, they create them one at a time, when the iteration, the for loop, demmands it. In this way, we have managed to add those numbers using much less memory. What we have done is to approach the problem using the iterator interface. An iterator is an object that:\n\nrepresents a stream of data, it yields its items one at a time.\nit raises a StopIteration exception when there are no more items to yield.\n\nLet’s sum the first ten numbers in a way that reflects the iterator protocol.\n\n\n\n\n\n\nWe get each number, one at at time, by calling next on the iterator until the iterator raises a StopIteration, and then we break the loop, we are done. That is in fact how the for loop works internally, it keeps calling next on the given object until it gets a StopIteration.\nWell, in fact, the for loop can make use of iterators, but also of other kind of objects. Lists, for instance, are not iterators. If you try to call next on a list you’ll get an error: “TypeError: ‘list’ object is not an iterator”\n\n\n\n\n\n\nLists are iterable, and we can create iterators from iterables by using the iter built-in function.\n\n\n\n\n\n\nThis is, more or less, what for does for us and, in that way, it can deal with both iterables and iterators.\nPython is fond of iterables and iterators, and has many functions that use them. Many common Python objects, although you might think that are sequences, are, in fact, iterators: objects returned by the dict keys, values and items, range or opened text files. And it also has the itertools module and the map, filter and reduce functions.\nTo sum the first numbers, we could even skip the for loop entirely to sum the numbers.\n\n\n\n\n\n\nNow that we don’t need to hold this numbers in memory we can use much less memory and sum the numbers faster.\n\n\n\n\n\n\nIf we would try to do the same creating the whole list, we would need much more time and memory.\n\n\n\n\n\n\n\n\nLazy and eager\nrange creates the numbers in a lazy way, it only creates a number when it is required. The opposite approach, the one used by the list, that creates all items ahead of time, is known as eager. Lazy approaches delay creation or computation as much as possible, while eager approaches create or compute as soon as they are instantiated or called.\n\n\nGenerators\nGenerators are a very convinient Python mechanism that allow us to create our own iterators. Generators look decively similar to a standard function, with the only difference that they use the yield statement instead of return. However, generators behave quite differently than standard functions.\n\n\n\n\n\n\nWhile the function only returns one item and stops, the generator is capable of yielding one item after another until it runs out of items. The call to the generator does not return any item at all, but a generator iterator object that, as any other iterator, will be able to yield items every time we ask for them using next.\nWhile each function call is independent, the function restarts its execution every time it is called from the very begining, generator iterators resume its execution every time we ask them to yield a new item.\n\n\n\n\n\n\nGenerators are a very convenient way of creating our own iterators. For instance, we could create a generator that yields the first n number (a very similar functionality that the one provided by the built-in range).\n\n\n\n\n\n\nOr we could create a generator of endless random numbers.\n\n\n\n\n\n\n\n\nIterators are consumed\nIterators are great tools, but you have to be aware of their behaviour, in particular, they are consumed.\n\n\n\n\n\n\nLists, on the contrary, are not consumed, we could go through them as many times as we want to.\n\n\n\n\n\n\nThink of iterators a stream of items that is seen only once. You should take into account this behaviour when creating algorithms that work with iterators. Although once you get used to them that won’t be a problem for many algorithms, it can be challenging at the begining to think on how to approach certain problems using iterators.\n\n\nitertools\nIf you plant to use iterators at all you should take a look at the itertools module, and if you want more functionality, you could check out the more-itertools package.",
    "crumbs": [
      "Functional programming"
    ]
  },
  {
    "objectID": "functional_programming.html#pure-and-inmutable",
    "href": "functional_programming.html#pure-and-inmutable",
    "title": "Functional programming",
    "section": "Pure and inmutable",
    "text": "Pure and inmutable\n\nPure functions\nA pure function is a function that:\n\ngiven the same arguments it will return the same values\ndoes not have any side effect\n\nPure functions have some advantages over functions that, for instance, have side effects, that change an external state. As we discussed in the procedural approach, side effects destroy modularity and make code more difficult to reason about and maintain.\n\n\nInmutable objects\nChanging the state of the objects passed to the function breaks modularity. So, programming is much easier, for instance code is easier to debug, when we don’t mutate the state of the objects passed to the function.\nIt is nice to have functions that do not change the objects that we lend to them, but the caller does not allways have control over the function implementation and one way to enforce this is to pass to the function only inmutable objects.",
    "crumbs": [
      "Functional programming"
    ]
  },
  {
    "objectID": "functional_programming.html#cache-and-paralellization",
    "href": "functional_programming.html#cache-and-paralellization",
    "title": "Functional programming",
    "section": "Cache and paralellization",
    "text": "Cache and paralellization\nWhen using pure functions and inmutable objects we can apply very easyly, tricks to improve the performance of our code.\nWe could, for instance, cache the result of time consuming computations. Since the function given the same arguments always returns the same values and the arguments are not changed, we can return a precomputed instance of the result.\nThe lru_cache decorator will cache the result of the function, so if you call the function several times with the same arguments, it will return the cached result and save you some possible expensive computations. Caching can, in some cases, improve code performance by a lot.\nfrom functools import lru_cache\n\n@lru_cache\ndef sum_numbers(a, b):\n    print(f\"Summing {a} + {b}\")\n    return a + b\n\nprint(sum_numbers(1, 1))\nprint(sum_numbers(1, 1))\nprint(sum_numbers(2, 2))\nprint(sum_numbers(1, 1))\nprint(sum_numbers(2, 2))\nOf course, lru_cache will not behave propertly with non-pure functions or with mutable arguments.\nPure functions and inmutable objects are also very convenient when dealing with large amounts of processing because it is much more easier to paralelize programs built with them.",
    "crumbs": [
      "Functional programming"
    ]
  },
  {
    "objectID": "functional_programming.html#functions-are-first-class-citizens",
    "href": "functional_programming.html#functions-are-first-class-citizens",
    "title": "Functional programming",
    "section": "Functions are first class citizens",
    "text": "Functions are first class citizens\nIn Python, like almost anything else, functions are just objects, and they can be used as arguments to other functions or can be returned by other functions. The functools has many utilies that take functions as arguments and that, in most cases, return functions.\nFor instance, the lru_cache decorator, like any other decorator is in fact a function that takes a function as an argument and returns another function.\n\npartial\npartial is another great utility of the functools module, it returns a new function which has some of their arguments precalled (or freezed).\nfrom functools import partial\n\ndef sum_numbers(a, b):\n    return a + b\n\n\nadd_2 = partial(sum_numbers, b=2)   # add_2 is a new function, created by partial\nprint(add_2(1))\nprint(add_2(7))\n\n\nlambda\nlambdas are small anonymous functions, functions with no name. They are usually passed as arguments to other functions.\nOne very common use case is to use them as the key argument of the sorted funtion when sorting.",
    "crumbs": [
      "Functional programming"
    ]
  },
  {
    "objectID": "functional_programming.html#comprenhensions",
    "href": "functional_programming.html#comprenhensions",
    "title": "Functional programming",
    "section": "Comprenhensions",
    "text": "Comprenhensions\nAll this functional utilities can be combined with several comprenhensions:\n\nlist comprehension\ndict comprehension\nset comprehension\ngenerator expression\n\nComprehensions provide a very consise way to create lists, dict, sets and generators by computing its values.\nThe general idea is: for each element in an iterable, if the element matches a condition, do something with the element and store the result in a list/dict/set.\n\n\n\n\n\n\nThe if condition is optional, we can create comprehensions without it.\n\n\n\n\n\n\nThe syntaxis for the dict and set comprehensions is very similar.\n\n\n\n\n\n\nAnd, finnaly, if we want, instead of creating a list eagerly, we could create a lazy generator, but changing the square brackets by parentheses.",
    "crumbs": [
      "Functional programming"
    ]
  },
  {
    "objectID": "functional_programming.html#filter-map-reduce",
    "href": "functional_programming.html#filter-map-reduce",
    "title": "Functional programming",
    "section": "filter, map, reduce",
    "text": "filter, map, reduce\nAnother very useful, and one of the most common, way of using the functional approach is to use filter, map and reduce. All these utilities are designed to work with iterators, with streams of data, and the map/reduce pattern was thought as a tool to process big quantities of data.\n\n\n\n\n\nflowchart TB\n    subgraph filter\n        f[\"filter(is_square_funct, item_iterator)\"]\n        subgraph filter_drawing\n            subgraph before_filter[\" \"]\n                1f[\" \"]\n                2f((\" \"))\n                3f((\" \"))\n                4f[\" \"]\n                5f[\" \"]\n            end\n            subgraph after_filter[\" \"]\n                1fa[\" \"]\n                4fa[\" \"]\n                5fa[\" \"]\n            end\n            before_filter ---&gt; after_filter\n        end\n    end\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n    subgraph map\n        m[\"map(to_square_funct, square_iterator)\"]\n        subgraph map_drawing[\" \"]\n            1s[\" \"]\n            2s[\" \"]\n            3s[\" \"]\n            4s[\" \"]\n            5s[\" \"]\n\n            1c((\" \"))\n            2c((\" \"))\n            3c((\" \"))\n            4c((\" \"))\n            5c((\" \"))\n\n            1s ---&gt; 1c\n            2s ---&gt; 2c\n            3s ---&gt; 3c\n            4s ---&gt; 4c\n            5s ---&gt; 5c\n        end\n    end\n\n\n\n\n\n\n\n\n\n\n\n\nThis is a somewhat convoluted way of writting the following algorithm:\n\n\n\n\n\n\nThe map-reduce approach splits the iteration functionality into the map and reduce functions, we have transformed the for, a loop statement, into a series of functions.\nThis approach offers the possibility of doing the computations in parallel because each call to map and reduce is independent, as long as we are using pure functions (no side effects), and the functions do not modify the objects passed to them (something that we could enforce using inmutable objects).\nPython, for instance, has a multiprocessing map that allow us to apply map in parallel.\n\n\n\n\n\n\nIf we can transform the computation that we are interested in carrying out into a series of pure functions, we can use this trick to do massive, and time and and memory efficient, computations in parallel. This is one of the main practial uses of the functional approach.",
    "crumbs": [
      "Functional programming"
    ]
  }
]