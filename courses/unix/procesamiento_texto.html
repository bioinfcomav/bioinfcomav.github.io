
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Procesamiento de ficheros de texto &mdash; Bioinformatics at COMAV 0.1 documentation</title>
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sphinx_highlight.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="Bioinformatics at COMAV 0.1 documentation" href="index.html" />
    <link rel="next" title="Expresiones regulares" href="expresiones_regulares.html" />
    <link rel="prev" title="Flujos de información" href="pipes.html" /> 
  </head>
  <body>

<div class="body">
    <header>
        <h1><a href="index.html">Bioinformatics at COMAV</a></h1>
    </header>


    <nav class="horizontal_nav page_nav">
        <ul>
            <li><a href="/index.html">Bioinformatics & genomics</a>
                <ul>
                    <li><a href="/services.html">Services</a></li>
                    <li><a href="/people.html">People</a></li>
                    <li><a href="/publications.html">Publications</a></li>
                    <li><a href="/getting_here.html">Getting here</a></li>
<!--                    <li><a href="http://bioinf.comav.upv.es/notes/">Wiki</a></li>-->
               </ul>
            </li>
            <li><a href="/software.html">Software</a>
                <ul>
                    <li><a href="https://github.com/bioinfcomav/">Bioinf COMAV</a></li>
                    <li><a href="https://github.com/JoseBlanca/">Jose Blanca</a></li>
                    <!--
                    <li><a href="/seq_crumbs/index.html">seq_crumbs</a></li>
                    <li><a href="/ngs_backbone/index.html">ngs_backbone</a></li>
                    <li><a href="/clean_reads/index.html">clean_reads</a></li>
                    <li><a href="/sff_extract/index.html">sff_extract</a></li>
                    <li><a href="/psubprocess/index.html">psubprocess</a></li>-->
               </ul>
            </li>
            <li><a href="/courses.html">Courses</a>
                <ul>
                    <li><a href="/courses/intro_bioinf/index.html">Bionformática básica</a></li>
                    <li><a href="/courses/sequence_analysis/index.html">NGS sequence analysis</a></li>
                    <li><a href="/courses/linux/index.html">Linux y Python</a></li>
                    <li><a href="/courses/unix/index.html">Linux para Biologos</a></li>
               </ul>
        </ul>
    </nav>

    <main>
                
    
  <section id="procesamiento-de-ficheros-de-texto">
<h1>Procesamiento de ficheros de texto<a class="headerlink" href="#procesamiento-de-ficheros-de-texto" title="Permalink to this heading">¶</a></h1>
<p>Uno de los puntos fuertes de los sistemas Unix estriba en la facilidad con la que pueden analizar los ficheros de texto en ellos.
Estos sistemas incluyen una serie de herramientas que permiten realizar una gran cantidad de manipulaciones en estos ficheros sin necesidad de instalar ninguna herramienta especializada.</p>
<p>En esta sección vamos a presentar varias de estas herramientas. Trabajaremos con el siguiente <a class="reference external" href="./demo_data/microarray_adenoma_hk69.ods">archivo de prueba</a>.</p>
<section id="ficheros-de-texto-y-binarios">
<h2>Ficheros de texto y binarios<a class="headerlink" href="#ficheros-de-texto-y-binarios" title="Permalink to this heading">¶</a></h2>
<p>Antes de comenzar a analizar los este tipo de ficheros debemos aclarar qué es y qué no es un <a class="reference external" href="https://en.wikipedia.org/wiki/Text_file">fichero de texto</a>.
Un fichero de texto es un fichero dividido en líneas y cuyo contenido es exclusivamente <a class="reference external" href="https://en.wikipedia.org/wiki/Plain_text">texto simple</a>, es decir, sólo hay caracteres alfanuméricos (letras y números), retornos de carro y tabuladores.
Los ficheros de texto pueden ser abiertos e inspeccionados sin necesidad de hacer uso de un software especial diseñado para trabajar con ellos.</p>
<p>A pesar de lo que pudiese parecer a priori, los documento de Microsoft Office o de LibreOffice no son ficheros de texto, contienen otras cosas como información de formato, estilo, tablas o imágenes.
La información contenida en estos documentos es binaria y sólo los programas especialmente creados para abrir estos ficheros pueden acceder a ella de un modo inteligible.</p>
<p>Uno de los puntos fundamentales de la filosofía Unix, es la utilización de ficheros de texto.
Mientras otros sistemas operativos favorecen la utilización de ficheros binarios, que deben ser acompañados de herramientas especiales para poder manipularlos, en Unix se optó por crear un conjunto de herramientas para manipulación de ficheros de texto y por utilizar para los ficheros del sistema sólo ficheros de texto siempre que esto fuese posible.</p>
</section>
<section id="editores-de-texto">
<h2>Editores de texto<a class="headerlink" href="#editores-de-texto" title="Permalink to this heading">¶</a></h2>
<p>En Linux existen editores de texto que funcionan con entorno gráfico, como el <em>gedit</em>, <em>KWrite</em> o <em>Leafpad</em>, y editores que funcionan en la terminal, como el <em>nano</em>, <em>pico</em> o <em>vim</em></p>
<p><em>vim</em> es un editor de texto potente y versátil pero dominar su manejo requiere bastante tiempo.</p>
<p><em>nano</em> es una versión mejorada de <em>pico</em>. Se trata de un editor simple y versátil pero mucho más fácil de usar que, por ejemplo, <em>vim</em> y está instalado por defecto en muchas distribuciones de Linux.</p>
<p>Vamos a ver cómo usar nano para crear o modificar archivos de texto, así como alguna de sus funcionalidades.</p>
<p>Podemos abrir <em>nano</em> directamente y se abrirá con un archivo vacio:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ nano
</pre></div>
</div>
<p>o bien indicarle la dirección de un archivo. En el caso que el archivo no exista lo creará.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ nano nombre_archivo
</pre></div>
</div>
<p>En la parte superior indica la versión y el nombre del archivo y en la parte superior se muestran algunas de las opciones del editor. Si deseamos ver una lista más completa podemos acceder a la ayuda mediante <em>Ctrl + g</em></p>
<ul class="simple">
<li><p>Crtl + x :       Cerrar el fichero / Salir de nano</p></li>
<li><p>Crtl + o :       Guardar</p></li>
<li><p>Alt + u :       Deshacer</p></li>
<li><p>Alt + e :        Rehacer</p></li>
</ul>
<p>Nos podemos mover por el documento con los cursores, y los botones de inicio, fin y avance y retroceso de página.</p>
<ul class="simple">
<li><p>Alt + a :        Seleccionar texto desde la posición actual del cursor</p></li>
<li><p>Alt +  6 :       Copiar selección o línea actual</p></li>
<li><p>Crtl + k :       Cortar selección o línea actual</p></li>
<li><p>Crtl + u :       Pegar</p></li>
<li><p>Alt +  w :      Buscar una cadena de texto o expresión regular</p></li>
<li><p>Crtl + :        Buscar y reemplazar una cadena de texto o expresión regular</p></li>
<li><p>Crtl + t :       Invocar el corrector ortográfico (requiere tener instalado <em>spell</em>)</p></li>
<li><p>Alt + d :        Contar el número de palabras, líneas y caracteres</p></li>
</ul>
</section>
<section id="imprimiendo-ficheros-cat-head-y-tail">
<h2>Imprimiendo ficheros <em>cat</em>, <em>head</em> y <em>tail</em><a class="headerlink" href="#imprimiendo-ficheros-cat-head-y-tail" title="Permalink to this heading">¶</a></h2>
<p>A veces, si los archivos son muy grandes incluso los editores en línea pueden tener problemas para abrirlos.
Otra forma de acceder a los contenidos del fichero sería imprimir el fichero en la terminal utilizando el comando <em>cat</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cat microarray_adenoma_hk69.ods
</pre></div>
</div>
<p>Recuerda que las herramientas que estamos viendo sólo sirven para trabjar con ficheros de texto, no binarios.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cat microarray_adenoma_hk69.csv
</pre></div>
</div>
<p>Si el archivo es extremadamente largo es posible que la terminal se bloquee durante bastante tiempo (Nota: recuerda que con <em>Crtl + c</em> los programas suelen terminar inmediatamente y se vuelve a mostrar el <em>prompt</em>.</p>
<p><em>cat</em> es además capaz de concatenar textos uno detrás de otro en el orden en que se los pasamos y mostrarlos en pantalla</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cat file1 file2 file3
</pre></div>
</div>
<p>Algunas opciones interesantes de <em>cat</em> son:</p>
<ul class="simple">
<li><p>-A : muestra también los caracteres de control, básicamente los tabuladores (como ^I) y los retornos de carro ($)</p></li>
<li><p>-n : numera todas las líneas</p></li>
</ul>
<p>Para hacernos una idea del contenido del fichero sin bloquear la terminal podemos imprimir tan solo las primeras líneas utilizando el comando <em>head</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ head microarray_adenoma_hk69.csv
&quot;!Exptid=10029&quot;
&quot;!Experiment Name=Adenoma (HK69)&quot;
&quot;!Organism=Homo sapiens&quot;
&quot;!Category=Adenoma&quot;
&quot;!Subcategory=Liver&quot;
&quot;!Experimenter=Xin Chen&quot;
&quot;!Contact email=chenx@pharmacy.ucsf.edu&quot;
&quot;!Contact Address1=Dept. of Biopharmaceutical Sciences&quot;
&quot;!Contact Address2=513 Parnassus Ave. S-816&quot;
&quot;!Contact Address3=Box 0446&quot;
</pre></div>
</div>
<p>Existe otro comando equivalente pero que nos permite imprimir el final de los archivos (<em>tail</em>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ tail microarray_adenoma_hk69.csv
24183       &quot;EMPTY&quot; &quot;EMPTY&quot; 19      27      32      0
</pre></div>
</div>
<p>Tanto a <em>head</em> como a <em>tail</em> podemos pedirles que impriman el número de líneas que nosotros deseemos mediante la opción <em>-n</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ head -n 2 microarray_adenoma_hk69.csv
&quot;!Exptid=10029&quot;
&quot;!Experiment Name=Adenoma (HK69)&quot;
</pre></div>
</div>
<p>Otro comportamiento de <em>tail</em> que resulta útil es que puede mostrar todas las líneas excepto las <em>k</em> primeras líneas. Para ello hay que usar la opción <em>-n</em> y el número de líneas que queremos omitir precedido por un <em>+</em>.
Por ejemplo, para omitir la cabecera del archivo de micro_adenoma que ocupa las primeras 20 líneas podemos hacer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ tail -n +20 microarray_adenoma_hk69.csv
</pre></div>
</div>
</section>
<section id="navegando-por-un-fichero-de-texto">
<h2>Navegando por un fichero de texto<a class="headerlink" href="#navegando-por-un-fichero-de-texto" title="Permalink to this heading">¶</a></h2>
<p>En muchas ocasiones para familiarizarnos con el fichero lo mejor es abrirlo y navegar por él.
Podríamos abrir el fichero con un editor de texto, pero ya hemos visto que si es muy grande podríamos tener problemas.
Existe una herramienta capaz de abrir ficheros de texto inmensos sin problemas, <em>less</em>.</p>
<p><em>less</em> es un visor de ficheros de texto, con este programa no podremos editar el fichero, pero sí navegar por su contenido.
<em>less</em> es un programa interactivo por lo que cuando lo ejecutemos se abrirá ocupando el terminal y haciendo desaparecer el <em>prompt</em>.
En cualquier momento podemos salir de <em>less</em> pulsando la tecla “q”.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ less microarray_adenoma_hk69.csv
</pre></div>
</div>
<p>Dentro de <em>less</em> disponemos de varios comandos para movernos por el fichero:</p>
<ul class="simple">
<li><p>barra de espacio: página siguiente.</p></li>
<li><p>b: página anterior.</p></li>
<li><p>100g: va a la línea 100 (o la que le indiquemos)</p></li>
<li><p>-S: corta o no corta las líneas largas</p></li>
<li><p>/palabra: Busca la cadena de texto que le indiquemos (acepta expresiones regulares)</p></li>
<li><p>n: va a la siguiente palabra que coincide con la búsqueda</p></li>
<li><p>N: va la palabra anterior que coincide con la búsqueda</p></li>
<li><p>q: sale del programa</p></li>
<li><p>h: ayuda</p></li>
</ul>
</section>
<section id="edicion-por-linea-de-comandos">
<h2>Edición por línea de comandos<a class="headerlink" href="#edicion-por-linea-de-comandos" title="Permalink to this heading">¶</a></h2>
<section id="wc">
<h3><em>wc</em><a class="headerlink" href="#wc" title="Permalink to this heading">¶</a></h3>
<p><em>wc</em> (<em>Word Count</em>) sirve para contar líneas, palabras y caracteres.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ wc leukemia microarray_adenoma_hk69.csv
</pre></div>
</div>
</section>
<section id="grep">
<h3><em>grep</em><a class="headerlink" href="#grep" title="Permalink to this heading">¶</a></h3>
<p>Una tarea que vamos a tener que realizar habitualmente es la de seleccionar diversas líneas en un fichero de texto.
Por ejemplo, imaginemos que queremos saber cual es la expresión de los genes relacionados con la leucemia en el fichero del <em>microarray</em>.
Esto, que en otros sistemas operativos podría resultar bastante complejo de hacer en Unix es trivial:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep leukemia microarray_adenoma_hk69.csv
3       &quot;IMAGE:302190&quot;  &quot;MLL&quot;   &quot;Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)&quot;
</pre></div>
</div>
<p><em>grep</em> (<em>Generalized Regular Expression Parser</em>) toma un fichero de entrada (o el <em>standard  input</em>) y filtra las líneas que contienen el patrón de búsqueda que le hemos dado. Por defecto incluye en el resultado las líneas que contienen el patrón, pero podríamos pedirle que haga lo contrario utilizando la opción <em>v</em> (<em>inVert</em>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -v leukemia microarray_adenoma_hk69.csv
  3       &quot;IMAGE:302190&quot;  &quot;MLL&quot;   &quot;Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)&quot;
</pre></div>
</div>
<p><em>grep</em> diferencia entre mayúsculas y minúsculas, pero podemos cambiar este comportamiento con la opción <em>i</em> (ignore case):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -i leukemia microarray_adenoma_hk69.csv
  3       &quot;IMAGE:302190&quot;  &quot;MLL&quot;   &quot;Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)&quot;
</pre></div>
</div>
<p>Si queremos saber en que posiciones del fichero original estaban las líneas que hemos encontrado podemos pedirle que imprima dichos números de línea:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -n leukemia microarray_adenoma_hk69.csv
</pre></div>
</div>
<p><em>grep</em> puede utilizarse para buscar recursivamente en todos los ficheros contenidos en un directorio.
Por ejemplo podríamos buscar la palabra <em>leukemia</em> en todos los ficheros presentes en alguno de nuestros directorios:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -r  leukemia ~
</pre></div>
</div>
<p><em>grep</em> tiene otras muchas opciones útiles, en su manual están todas descritas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ man grep
</pre></div>
</div>
<p><em>grep</em> hace uso de las expresiones regulares que veremos posteriormente por lo que su potencia es mucho mayor que la que ahora podemos imaginar.</p>
<p>Otra de las ventajas de <em>grep</em> viene dada por su adherencia a los principios Unix lo que implica que podemos utilizar <em>grep</em> enlazándolo con otros programas.
Imaginemos que queremos hacer una búsqueda limitada a las primeras cien líneas del fichero, podríamos hacer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia
</pre></div>
</div>
<p>Lo que hemos hecho es utilizar el comando <em>head</em> para leer las primeras cien líneas del archivo, pero en vez de imprimir el resultado en pantalla hemos redirigido su salida mediante una tubería (<em>pipe</em>) al comando <em>grep</em>.
Éste ha tomado estas cien líneas y las ha filtrado con la palabra <em>leukemia</em>.
Podríamos además redirigir el resultado final a un fichero para guardar el resultado:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia &gt; busqueda_leukemia_100.txt
</pre></div>
</div>
<p>o bien pasárselo a otro programa, por ejemplo, a <em>wc</em> para que cuente el número de veces que aparece <em>leukemia</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia | wc
</pre></div>
</div>
<p>Todos los comandos de manejo de texto que vamos a ver en esta sección tienen esta capacidad.
Todos siguen el principio de realizar una tarea concreta pero teniendo la capacidad de enlazarse con otros.</p>
</section>
<section id="cut">
<h3><em>cut</em><a class="headerlink" href="#cut" title="Permalink to this heading">¶</a></h3>
<p>Cuando el fichero está dividido en campos, como en el caso de la tabla que estamos utilizando, podemos seleccionar alguno de estos campos utilizando el comando <em>cut</em>.
Por ejemplo mejoremos la búsqueda que habíamos hecho quedándonos tan solo con el nombre del gen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3
&quot;BAALC&quot;
&quot;DEK&quot;
</pre></div>
</div>
<p>Con el parámetro <em>-f</em> le indicamos la lista de campos (<em>fields</em>) que queremos seleccionar.</p>
<p>Para indicar los campos que queremos seleccionar:</p>
<ul class="simple">
<li><p>N    : el campo N (p.e., cut -f 3 file1)</p></li>
<li><p>N- : desde el campo N hasta el final (p.e., cut -f 3- file1)</p></li>
<li><p>N-M : desde el campo N al M (p.e., cut -f 3-6 file1)</p></li>
<li><p>-M : desde el primer campo al campo M (p.e., cut -f -3 file1)</p></li>
<li><p>N,M : los campos indicados (p.e., cut -f 3,6,8 file1)</p></li>
</ul>
<p>Así podríamos seleccionar los campos del 3 al 5 y del 8 al 10:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cut -f 3-5,8-10 microarray_adenoma_hk69.csv
</pre></div>
</div>
<p><em>cut</em> asume que los campos en el fichero están divididos por tabuladores.
Pero podríamos indicarle que los campos están divididos de otro modo, por ejemplo por comas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cut -d &#39;,&#39; fichero_separado_por_comas.txt
</pre></div>
</div>
<p>Para tener una idea completa de las capacidades ofrecidas por el comando conviene consultar su manual:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ man cut
</pre></div>
</div>
</section>
<section id="sed">
<h3><em>sed</em><a class="headerlink" href="#sed" title="Permalink to this heading">¶</a></h3>
<p>El <em>sed</em> (<em>stream editor</em>) es un editor de texto un tanto especial que toma las líneas de una en una,
les aplica la transformación que le indiquemos y devuelve las líneas modificadas.</p>
<p>Por ejemplo, la lista de genes que hemos obtenido en el apartado anterior puede servirnos para muchos propósitos, pero todavía no está limpia del todo, quedaría mejor si eliminásemos las comillas que rodean los campos:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4 | sed  &quot;s/\&quot;//g&quot;
BAALC   Brain and acute leukemia, cytoplasmic
DEK     DEK oncogene (DNA binding)
</pre></div>
</div>
<p>El <em>sed</em> además de sustituir puede realizar cualquier tipo de edición sobre un texto.
La sintaxis utilizada por <em>sed</em> puede resultar algo oscura al principio, pero un mínimo conocimiento de este comando nos permitirá hacer modificaciones en el texto que de otro modo serían muy complejas.</p>
<p>En este curso nos centraremos en el uso del <em>sed</em> para sustituciones. En el ejemplo anterior, el comando sed que hemos utilizado es “s/&quot;//g”.
En primer lugar hemos indicado a <em>sed</em> qué queríamos hacer.
Podemos, como es el caso, substituir un patrón por otro (comando s, sustituir), pero también podríamos pedirle que eliminase líneas (comando d, delete).
Para substituir hay que indicarle qué queremos substituir y por qué:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">/</span><span class="n">patrón_a_substituir</span><span class="o">/</span><span class="n">nuevo_patrón</span><span class="o">/</span>
</pre></div>
</div>
<p>En el ejemplo hemos substituido las comillas por nada. En principio deberíamos haber escrito “s/”//”.
Pero dado que las comillas tienen un significado especial en este contexto debemos <em>escaparlas</em>, por eso escribimos “s/&quot;//”.
Además, a la expresión le hemos añadido una “g”, con este modificador le indicamos a <em>sed</em> que no queremos que substituya sólo la primera aparición del patrón en la línea sino todos los que haya.</p>
<p><em>sed</em> acepta expresiones regulares como patrones y con ellas puede realizar prácticamente cualquier substitución que podamos imaginar.</p>
</section>
<section id="sort">
<h3><em>sort</em><a class="headerlink" href="#sort" title="Permalink to this heading">¶</a></h3>
<p>Si deseamos ordenar alfabéticamente un fichero de texto tan sólo tenemos que utilizar el comando <em>sort</em>.
Por ejemplo, podemos ordenar los genes relacionados con la leucemia:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4| sort
</pre></div>
</div>
<p><em>sort</em> también puede hacer ordenaciones numéricas y puede ordenar por cualquiera de los campos presentes en el fichero.
Para ver qué se puede hacer con <em>sort</em> lo más recomendable es leer su manual.</p>
</section>
<section id="uniq">
<h3><em>uniq</em><a class="headerlink" href="#uniq" title="Permalink to this heading">¶</a></h3>
<p>En el ejemplo anterior, al ordenar con <em>sort</em>, hemos visto que en la lista que hemos obtenido hay genes repetidos.
Con el comando <em>uniq</em> podemos eliminar las líneas duplicadas consecutivas.
Para que la eliminación sea completa hay que recordad ordenar con <em>sort</em> antes de utilizar <em>uniq</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4| sort | uniq
</pre></div>
</div>
</section>
<section id="shuf">
<h3><em>shuf</em><a class="headerlink" href="#shuf" title="Permalink to this heading">¶</a></h3>
<p><em>shuf</em> permite obtener permutaciones aleatorias del archivo de entrada, o bien obtener líneas aleatorias.</p>
<p>Si no le pasamos ningún parámeto a <em>shuf</em> obtendremos permutaciones aleatorias:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ ls / | shuf
</pre></div>
</div>
<p>o bien le podemos pedir el número de líneas aleatorias que deseemos.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4 | shuf -n 5
</pre></div>
</div>
</section>
</section>
<section id="herramientas-para-unir-archivos">
<h2>Herramientas para unir archivos<a class="headerlink" href="#herramientas-para-unir-archivos" title="Permalink to this heading">¶</a></h2>
<section id="paste">
<h3><em>paste</em><a class="headerlink" href="#paste" title="Permalink to this heading">¶</a></h3>
<p><em>paste</em> une ficheros tabulares línea por línea.
Supongamos que tenemos dos ficheros, uno con datos sobre la progresión de la enfermedad de una serie de enfermos y otro con el genotipado de los mismos:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pacientes</span><span class="p">:</span>
<span class="n">id_paciente</span><span class="p">,</span><span class="n">nivel_colesterol</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">190</span>
<span class="mi">2</span><span class="p">,</span><span class="mi">250</span>
<span class="mi">3</span><span class="p">,</span><span class="mi">220</span>
<span class="mi">4</span><span class="p">,</span><span class="mi">260</span>
<span class="mi">5</span><span class="p">,</span><span class="mi">160</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">genotipado</span><span class="p">:</span>
<span class="n">id_paciente</span><span class="p">,</span><span class="n">SNP_a</span><span class="p">,</span><span class="n">SNP_b</span>
<span class="mi">1</span><span class="p">,</span><span class="n">AA</span><span class="p">,</span><span class="n">CC</span>
<span class="mi">2</span><span class="p">,</span><span class="n">AC</span><span class="p">,</span><span class="n">GG</span>
<span class="mi">3</span><span class="p">,</span><span class="n">AA</span><span class="p">,</span><span class="n">CG</span>
<span class="mi">4</span><span class="p">,</span><span class="n">AT</span><span class="p">,</span><span class="n">GG</span>
<span class="mi">5</span><span class="p">,</span><span class="n">AA</span><span class="p">,</span><span class="n">CC</span>
</pre></div>
</div>
<p>Podemos fusionar los dos archivos usando el comando paste:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ paste -d&#39;,&#39; pacientes.txt genotipado.txt
id_paciente,nivel_colesterol,id_paciente,SNP_a,SNP_b
1,190,1,AA,CC
2,250,2,AC,GG
3,220,3,AA,CG
4,260,4,AT,GG
5,160,5,AA,CC
</pre></div>
</div>
</section>
<section id="join">
<h3><em>join</em><a class="headerlink" href="#join" title="Permalink to this heading">¶</a></h3>
<p><em>join</em> es una herramienta muy potente, pero sencilla. Permite unir dos ficheros de texto en uno usando una columna como clave común. Por defecto, <em>join</em> asume que el separador de campos es el espacio.</p>
<p><em>join</em> es una especie de <em>paste</em> en la que la columna común que sirve como enlace entre ambas tablas no queda duplicada y no requiere que un elemento esté en los dos archivos. <em>join</em> lo que sí que requiere es que ambos archivos estén ordenados por la columna que se queiere usar como clave
Imaginemos que tenemos los dos ficheros siguientes: <a class="reference external" href="./demo_data/file1.txt">file1.txt</a> y <a class="reference external" href="./demo_data/file2.txt">file2.txt</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">file1</span><span class="o">.</span><span class="n">txt</span><span class="p">:</span>
<span class="n">num</span> <span class="nb">id</span> <span class="n">atributo</span>
<span class="mi">1</span> <span class="n">abc</span> <span class="n">fff</span>
<span class="mi">2</span> <span class="n">efg</span> <span class="n">aaa</span>
<span class="mi">5</span> <span class="n">klm</span> <span class="n">bbb</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">file2</span><span class="o">.</span><span class="n">txt</span><span class="p">:</span>
<span class="n">num</span> <span class="nb">id</span> <span class="n">atributo</span>
<span class="mi">1</span> <span class="n">abc</span> <span class="n">ttt</span>
<span class="mi">3</span> <span class="n">klm</span> <span class="n">fff</span>
<span class="mi">5</span> <span class="n">opq</span> <span class="n">jjj</span>
<span class="mi">9</span> <span class="n">rst</span> <span class="n">ttt</span>
</pre></div>
</div>
<p><em>join</em> nos permite unir estas dos tablas en una sola utilizando el campo <em>num</em> como la clave de unión:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ join file1.tx file2.tx
num id atributo id atributo
1 abc fff abc ttt
5 klm bbb opq jjj
</pre></div>
</div>
<p>Por defecto, <em>join</em> asume que la clave de unión es la primera columna, pero esto se puede modificar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ join -1 2 -2 2 file1.tx file2.tx
id num atributo num atributo
abc 1 fff 1 ttt
klm 5 bbb 3 fff
</pre></div>
</div>
<p>Las filas que no son comunes entre ambos archivos no se devuelven por defecto, pero esto también es modificable y podemos solicitar que nos devuelva todas las de un archivo, las del otro o las de los dos:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ join -a1 -1 2 -2 2 file1.tx file2.tx
id num atributo num atributo
abc 1 fff 1 ttt
efg 2 aaa
klm 5 bbb 3 fff
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ join -a1 -a2 -1 2 -2 2 file1.tx file2.tx
id num atributo num atributo
abc 1 fff 1 ttt
efg 2 aaa
klm 5 bbb 3 fff
opq 5 jjj
rst 9 ttt
</pre></div>
</div>
</section>
</section>
<section id="codificacion-de-caracteres">
<h2>Codificación de caracteres<a class="headerlink" href="#codificacion-de-caracteres" title="Permalink to this heading">¶</a></h2>
<p>Los ordenadores codifican los caracteres del lenguaje natural utilizando números.
Los ficheros de texto no son pues más que ficheros de números que el ordenador transforma en caracteres utilizando una tabla de codificación de caracteres antes de imprimirlos.
Una de las tablas de codificación más populares es la <a class="reference external" href="https://es.wikipedia.org/wiki/ASCII">ASCII</a>, en ella se incluyen los caracteres utilizados en la lengua inglesa, pero no los acentos o los caracteres de otros alfabetos.
Para solucionar el problema el ASCII original fue ampliado creándose distintas tablas, una por cada lengua natural.
De este modo con el ASCII correspondiente al castellano podemos crear ficheros de texto con acentos.
Pero al crear distintas tablas de codificación surgió un problema, si nos equivocamos de tabla al decodificar el fichero obtendremos caracteres extraños que no se corresponden con lo que originalmente se había escrito.
Para solucionar el problema se creó la norma <a class="reference external" href="https://es.wikipedia.org/wiki/Unicode">Unicode</a>, que es una gran tabla con unos 100713 símbolos que codifican prácticamente todos los caracteres utilizados en casi cualquier alfabeto humano.</p>
<p>El problema práctico al que nos enfrentamos es que para poder abrir un fichero de texto que incluya caracteres no ingleses debemos conocer la tabla de caracteres en la que fue codificado.
En Linux los ficheros de texto se codifican mediante <em>UTF-8</em> que es una de las tablas del estándar <em>Unicode</em>, pero en <em>Windows</em> no se sigue este estándar.
Las instalaciones de Windows en castellano utilizan la tabla Windows-1252.</p>
<p>Normalmente los editores de texto permiten elegir la tabla de caracteres en la que el fichero ha sido codificado.
Si abrimos un fichero y vemos que tiene símbolos raros lo más normal es que estemos utilizando una tabla de caracteres equivocada.
Este problema también suele ocurrir en las páginas web. Una página web no es más que un fichero de texto con un formato determinado.
Si el navegador no es capaz de inferir la codificación del fichero los acentos pueden aparecer como caracteres extraños.</p>
<p>En Linux hay varios programas que nos permiten cambiar los ficheros de una tabla de codificación a otra, uno de ellos es <em>iconv</em>.
Por ejemplo si tenemos un archivo con una codificación <a class="reference external" href="./demo_data/sagan.utf-8.txt">UTF-8</a> o <a class="reference external" href="./demo_data/sagan.iso-8859-1.txt">ISO-8859-1</a> podemos pasar de una a otra con <em>iconv</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ iconv -t ISO-8859-1 -f UTF-8 sagan.iso-8859-1 &gt; sagan.utf-8_mod.txt
~$ iconv -f ISO-8859-1 -t UTF-8 sagan.utf-8.txt &gt; sagan.iso-8859-1_mod.txt
</pre></div>
</div>
</section>
<section id="fin-de-linea">
<h2>Fin de línea<a class="headerlink" href="#fin-de-linea" title="Permalink to this heading">¶</a></h2>
<p>Para marcar el final de una línea en un fichero de texto se utiliza un carácter especial.
Por desgracia no ha habido un acuerdo a la hora de decidirse cual es el carácter que debe usarse.
Unix, Windows y Mac OS utilizan caracteres diferentes.
Afortunadamente los editores de texto suelen ser capaces de detectar las tres versiones y muestran el fichero con las líneas que esperamos.
Desgraciadamente el notepad del Windows no es capaz de hacerlo por lo que si abrimos un fichero de texto creado en Linux en el notepad nos aparecerá como una larga línea con símbolos extraños intercalados.
Casi todos los editores de texto permiten hacer el cambio entre los distintos finales de línea.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ unix2dos -n sagan.utf-8.txt sagan.dos.tx
~$ cat -A sagan.uft-8.txt
~$ cat -A sagan.dos.txt
~$ dos2unix sagan.dos.tx
~$ cat -A sagan.dos.txt
</pre></div>
</div>
</section>
<section id="ejercicios">
<h2>Ejercicios<a class="headerlink" href="#ejercicios" title="Permalink to this heading">¶</a></h2>
<p>Se ha realizado un estudio de un nuevo tratamiento para un linfoma y nos han enviado dos ficheros.
En el llamando <a class="reference external" href="demo_data/cancer_progresion.txt">cancer_progresion.txt</a> se encuentran tanto los datos de los pacientes como el resultado del tratamiento.
En el <a class="reference external" href="demo_data/cancer_ciego.txt">segundo</a> se encuentra la tabla que nos permitirá desentrañar el ensayo del doble ciego, con el identificador de cada paciente y la dosis de droga que se le administró.</p>
<ol class="arabic simple">
<li><p>Sobre el archivo microarray_adenoma_hk69, recupera sólo el primer resultado.</p></li>
<li><p>¿Cuántos pacientes había en el estudio?</p></li>
<li><p>¿De cuántos pacientes no tenemos datos de progresión?</p></li>
<li><p>Convertir la separación de comas de la tabla de doble ciego a tabuladores (el tabulador se escribe como t).</p></li>
<li><p>Unir la tabla de los resultados de la terapia con la del doble ciego.</p></li>
<li><p>Transformar el fichero resultante las comas a tabuladores.</p></li>
<li><p>¿Cómo les ha ido a los pacientes según el tipo de tratamiento? (Placebo está escrito con mayúsculas y minúsculas)</p></li>
<li><p>Crea un fichero con los primeros 100 resultados del microarray de adenoma que incluya sólo las primeras 10 columnas.</p></li>
<li><p>Ordena el fichero micro.txt generado en la cuestión 7 por el nombre del gen (campo 3) y por el id de la fila, pero en orden numérico reverso.</p></li>
<li><p>Disponemos de dos ficheros con secuencias de ADN: <a class="reference external" href="demo_data/seqs_1.fasta">seqs_1.fasta</a> y <a class="reference external" href="demo_data/seqs_2.fasta">seqs_2.fasta</a> ¿Cuántas secuencias hay en cada fichero? ¿Hay alguna secuencia presente en ambos ficheros? (En los archivos de secuencia tipo fasta el nombre de las secuencias se encuentra en las líneas que comienzan por el símbolo <em>&gt;</em>)</p></li>
<li><p>Disponemos de un fichero con <a class="reference external" href="demo_data/seqs_3.fasta">secuencia de ADN</a>, puedes extraer los nombres de las sequencias?</p></li>
<li><p>Disponemos de un fichero con el resultado de un mapeo en <a class="reference external" href="demo_data/tomate.sam">formato SAM</a> ¿Cuntas secuencias se han mapeado? ¿Cuántas se han mapeado en dirección reversa (mirad la segunda columna: 0 forward; 16 reverse)? ¿Cuántos y cuáles son los unigenes a los que se ha podido mapear alguna secuencia? Ordena las nombres de secuencias mapeadas con el orden del unigene y la posición en el unigene.</p></li>
</ol>
</section>
<section id="soluciones">
<h2>Soluciones<a class="headerlink" href="#soluciones" title="Permalink to this heading">¶</a></h2>
<p>1.- Sobre el archivo microarray_adenoma_hk69, recupera sólo el primer resultado.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ tail -n +21 microarray_adenoma_hk69.csv | head -1
</pre></div>
</div>
<p>2.- ¿Cuántos pacientes había en el estudio?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -v nombre cancer_progresion.txt | wc -l
11
</pre></div>
</div>
<p>3.- ¿De cuántos pacientes no tenemos datos de progresión?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep  desconocido cancer_progresion.txt  | wc -l
1
</pre></div>
</div>
<dl class="simple">
<dt>4.- Convertir la separación de comas de la tabla de doble ciego  a tabuladores.</dt><dd><p>(El tabulador se escribe como t)</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ sed -e &#39;s/,/\t/&#39; cancer_ciego.txt &gt; cancer_ciego_tab.txt
</pre></div>
</div>
<p>5.- Unir la tabla de los resultados de la terapia con la del doble ciego.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ join cancer_progresion.txt cancer_ciego_tab.txt &gt; cancer.txt
</pre></div>
</div>
<p><em>join</em>, por defecto, crea la nueva tabla usando como separador los espacios.
Para poder hacerlo correctamente con tabuladores habría que usar “join -t $’t’”.
Otro modo correcto y más sencillo de hacerlo sería pasar antes todos los tabuladores a comas y hacerlo con comas.
Estas herramientas tienen este tipo de limitaciones, más adelante con Python podremos superarlas fácilmente.</p>
<p>6.- Transformar el fichero resultante los espacios a tabuladores.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ sed -e &#39;s/ /\t/g&#39; cancer.txt
</pre></div>
</div>
<p>7.- ¿Cómo les ha ido a los pacientes según el tipo de tratamiento? (Placebo está escrito con mayúsculas y minúsculas)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -i placebo cancer.txt
1 Pepe Granada buena placebo
4 Mónica Madrid mala placebo
7 Óscar Barcelona mala Placebo
10 Jordi Barcelona mala Placebo
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -i 1mg cancer.txt
2 Juan Lugo muy buena 1mg
3 Alicia Valencia muy buena 1mg
8 Trini Valencia muy buena 1mg
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -i 2mg cancer.txt
5 Alberto Madrid regular 2mg
6 Toni Toledo mala 2mg
9 Pepe Valencia buena 2mg
11 Manolo Sevilla desconocido 2mg
</pre></div>
</div>
<p>8.- Crea un fichero con los primeros 100 resultados del microarray de adenoma que incluya sólo las primeras 10 columnas.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -v &#39;^&quot;&#39; microarray_adenoma_hk69.csv | head -n 100 | cut -f 1-10 &gt; micro.txt
</pre></div>
</div>
<p>9.- Ordena el fichero micro.txt generado en la cuestión 7 por el nombre del gen (campo 3) y por el id de la fila, pero en orden numérico reverso.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ sort -k 3 micro.txt
~$ sort -nr micro.txt
</pre></div>
</div>
<p>10.- Disponemos de dos ficheros con secuencias de ADN (seqs_1.fasta y seqs_2.fasta). ¿Cuántas secuencias hay en cada fichero? ¿Hay alguna secuencia presente en ambos ficheros? (En los archivos de secuencia tipo fasta el nombre de las secuencias se encuentra en las líneas que comienzan por el símbolo <em>&gt;</em>)</p>
<p>Veamos cuantas secuencias hay en cada archivo y después contemos las secuencias no repetidas que hay en un archivo que las incluya a todas.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cat seqs_1.fasta | grep &#39;&gt;&#39; | wc -l
11
~$ cat seqs_2.fasta | grep &#39;&gt;&#39; | wc -l
11
~$ cat seqs_1.fasta seqs_2.fasta | grep &#39;&gt;&#39; | sort | uniq | wc -l
20
</pre></div>
</div>
<p>Sí hay secuencias repetidas puesto que cuando las contamos todas juntas hay dos menos que cuando las contamos por separado.
Podemos ver qué secuencias hay repetidas utilizando el parámetro <em>-d</em> del uniq:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cat seqs_1.fasta seqs_2.fasta | grep &#39;&gt;&#39; | sort | uniq -d
&gt;gi|311207420|gb|GT728904.1|GT728904
&gt;gi|311210057|gb|GT715712.1|GT715712
</pre></div>
</div>
<p>Efectivamente ambas secuencias se encuentran repetidas en los dos ficheros:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep &#39;&gt;gi|311207420|gb|GT728904.1|GT728904&#39; seqs_1.fasta
&gt;gi|311207420|gb|GT728904.1|GT728904
$ grep &#39;&gt;gi|311207420|gb|GT728904.1|GT728904&#39; seqs_2.fasta
&gt;gi|311207420|gb|GT728904.1|GT728904
</pre></div>
</div>
<p>11.- Para poder extraer los nombres conviene primero echar un vistazo al fichero para ver que contiene.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep &quot;&gt;&quot; seqs_3.fasta|cut -c 2- | cut -f 1 -d &quot; &quot;
</pre></div>
</div>
<p>12.-</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ grep -v &quot;^@&quot; tomate.sam | wc
~$ grep -v &quot;^@&quot; tomate.sam | cut -f 2 | grep 16 | wc
~$ grep -v &quot;^@&quot; tomate.sam | cut -f 3 | sort -u
~$ grep -v &quot;^@&quot; tomate.sam | sort -k 3,4 |cut -f 1
</pre></div>
</div>
</section>
<section id="bibliografia">
<h2>Bibliografía<a class="headerlink" href="#bibliografia" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>Chris Herborth, <a class="reference external" href="http://www.ibm.com/developerworks/aix/library/au-textprocess.html">Text processing with UNIX</a></p></li>
<li><p>TDLP, <a class="reference external" href="http://tldp.org/LDP/abs/html/textproc.html">Text Processing Commands</a></p></li>
</ul>
</section>
</section>



        

    </main>

</div>
    <footer>
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/"><img alt="Licencia de Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" property="dct:title">Bioinformatics at COMAV</span> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Reconocimiento 4.0 Internacional License</a>.
    </footer>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-16108274-1");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>