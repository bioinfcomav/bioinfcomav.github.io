<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Procesamiento de ficheros de texto</title>
  <meta name="description" content="Introduction to the Linux command line.">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/procesamiento_texto.html">
  <link rel="alternate" type="application/rss+xml" title="Curso Unix" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Curso Unix</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/index.html">Curso Unix</a>
          
        
          
          <a class="page-link" href="/unix_intro.html">Unix y Linux</a>
          
        
          
          <a class="page-link" href="/sistema_de_ficheros.html">El sistema de ficheros</a>
          
        
          
          <a class="page-link" href="/control_procesos.html">Procesos</a>
          
        
          
          <a class="page-link" href="/pipes.html">Flujos de información</a>
          
        
          
          <a class="page-link" href="/procesamiento_texto.html">Procesamiento de ficheros de texto</a>
          
        
          
          <a class="page-link" href="/expresiones_regulares.html">Expresiones regulares</a>
          
        
          
          <a class="page-link" href="/scripts_bash.html">Scripts de bash</a>
          
        
          
          <a class="page-link" href="/administrador.html">Administrador</a>
          
        
          
          <a class="page-link" href="/administracion_software1.html">Administracion de software 1</a>
          
        
          
          <a class="page-link" href="/variables_de_entorno.html">Variables de entorno</a>
          
        
          
          <a class="page-link" href="/administracion_software2.html">Administracion de software 2</a>
          
        
          
          <a class="page-link" href="/redes.html">Redes</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Procesamiento de ficheros de texto</h1>
  </header>

  <div class="post-content">
    <ul id="markdown-toc">
  <li><a href="#ficheros-de-texto-y-binarios" id="markdown-toc-ficheros-de-texto-y-binarios">Ficheros de texto y binarios</a></li>
  <li><a href="#editores-de-texto" id="markdown-toc-editores-de-texto">Editores de texto</a></li>
  <li><a href="#imprimiendo-ficheros-cat-head-y-tail" id="markdown-toc-imprimiendo-ficheros-cat-head-y-tail">Imprimiendo ficheros <em>cat</em>, <em>head</em> y <em>tail</em></a></li>
  <li><a href="#navegando-por-un-fichero-de-texto" id="markdown-toc-navegando-por-un-fichero-de-texto">Navegando por un fichero de texto</a></li>
  <li><a href="#edición-por-línea-de-comandos" id="markdown-toc-edición-por-línea-de-comandos">Edición por línea de comandos</a>    <ul>
      <li><a href="#wc" id="markdown-toc-wc"><em>wc</em></a></li>
      <li><a href="#grep" id="markdown-toc-grep"><em>grep</em></a></li>
      <li><a href="#cut" id="markdown-toc-cut"><em>cut</em></a></li>
      <li><a href="#sed" id="markdown-toc-sed"><em>sed</em></a></li>
      <li><a href="#sort" id="markdown-toc-sort"><em>sort</em></a></li>
      <li><a href="#uniq" id="markdown-toc-uniq"><em>uniq</em></a></li>
      <li><a href="#shuf" id="markdown-toc-shuf"><em>shuf</em></a></li>
    </ul>
  </li>
  <li><a href="#herramientas-para-unir-archivos" id="markdown-toc-herramientas-para-unir-archivos">Herramientas para unir archivos</a>    <ul>
      <li><a href="#paste" id="markdown-toc-paste"><em>paste</em></a></li>
      <li><a href="#join" id="markdown-toc-join"><em>join</em></a></li>
    </ul>
  </li>
  <li><a href="#codificación-de-caracteres" id="markdown-toc-codificación-de-caracteres">Codificación de caracteres</a></li>
  <li><a href="#fin-de-línea" id="markdown-toc-fin-de-línea">Fin de línea</a></li>
  <li><a href="#ejercicios" id="markdown-toc-ejercicios">Ejercicios</a></li>
  <li><a href="#soluciones" id="markdown-toc-soluciones">Soluciones</a></li>
  <li><a href="#bibliografía" id="markdown-toc-bibliografía">Bibliografía</a></li>
</ul>

<p>Uno de los puntos fuertes de los sistemas Unix estriba en la facilidad con la que pueden analizar los ficheros de texto en ellos.
Estos sistemas incluyen una serie de herramientas que permiten realizar una gran cantidad de manipulaciones en estos ficheros sin necesidad de instalar ninguna herramienta especializada.</p>

<p>En esta sección vamos a presentar varias de estas herramientas. Trabajaremos con el siguiente <a href="./demo_data/microarray_adenoma_hk69.ods">archivo de prueba</a>.</p>

<h2 id="ficheros-de-texto-y-binarios">Ficheros de texto y binarios</h2>

<p>Antes de comenzar a analizar los este tipo de ficheros debemos aclarar qué es y qué no es un <a href="https://en.wikipedia.org/wiki/Text_file">fichero de texto</a>.
Un fichero de texto es un fichero dividido en líneas y cuyo contenido es exclusivamente <a href="https://en.wikipedia.org/wiki/Plain_text">texto simple</a>, es decir, sólo hay caracteres alfanuméricos (letras y números), retornos de carro y tabuladores.
Los ficheros de texto pueden ser abiertos e inspeccionados sin necesidad de hacer uso de un software especial diseñado para trabajar con ellos.</p>

<p>A pesar de lo que pudiese parecer a priori, los documento de Microsoft Office o de LibreOffice no son ficheros de texto, contienen otras cosas como información de formato, estilo, tablas o imágenes.
La información contenida en estos documentos es binaria y sólo los programas especialmente creados para abrir estos ficheros pueden acceder a ella de un modo inteligible.</p>

<p>Uno de los puntos fundamentales de la filosofía Unix, es la utilización de ficheros de texto.
Mientras otros sistemas operativos favorecen la utilización de ficheros binarios, que deben ser acompañados de herramientas especiales para poder manipularlos, en Unix se optó por crear un conjunto de herramientas para manipulación de ficheros de texto y por utilizar para los ficheros del sistema sólo ficheros de texto siempre que esto fuese posible.</p>

<h2 id="editores-de-texto">Editores de texto</h2>

<p>En Linux existen editores de texto que funcionan con entorno gráfico, como el <em>gedit</em>, <em>KWrite</em> o <em>Leafpad</em>, y editores que funcionan en la terminal, como el <em>nano</em>, <em>pico</em> o <em>vim</em></p>

<p><em>vim</em> es un editor de texto potente y versátil pero dominar su manejo requiere bastante tiempo.</p>

<p><em>nano</em> es una versión mejorada de <em>pico</em>. Se trata de un editor simple y versátil pero mucho más fácil de usar que, por ejemplo, <em>vim</em> y está instalado por defecto en muchas distribuciones de Linux.</p>

<p>Vamos a ver cómo usar nano para crear o modificar archivos de texto, así como alguna de sus funcionalidades.</p>

<p>Podemos abrir <em>nano</em> directamente y se abrirá con un archivo vacio:</p>

<div class="highlighter-rouge"><pre class="highlight"><code> ~$ nano
</code></pre>
</div>

<p>o bien indicarle la dirección de un archivo. En el caso que el archivo no exista lo creará.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> ~$ nano nombre_archivo
</code></pre>
</div>

<p>En la parte superior indica la versión y el nombre del archivo y en la parte superior se muestran algunas de las opciones del editor. Si deseamos ver una lista más completa podemos acceder a la ayuda mediante <em>Ctrl + g</em></p>

<ul>
  <li>Crtl + x :       Cerrar el fichero / Salir de nano</li>
  <li>
    <p>Crtl + o :       Guardar</p>
  </li>
  <li>Alt + u :       Deshacer</li>
  <li>Alt + e :        Rehacer</li>
</ul>

<p>Nos podemos mover por el documento con los cursores, y los botones de inicio, fin y avance y retroceso de página.</p>

<ul>
  <li>Alt + a :        Seleccionar texto desde la posición actual del cursor</li>
  <li>Alt +  6 :       Copiar selección o línea actual</li>
  <li>Crtl + k :       Cortar selección o línea actual</li>
  <li>
    <p>Crtl + u :       Pegar</p>
  </li>
  <li>Alt +  w :      Buscar una cadena de texto o expresión regular</li>
  <li>
    <p>Crtl + \ :        Buscar y reemplazar una cadena de texto o expresión regular</p>
  </li>
  <li>Crtl + t :       Invocar el corrector ortográfico (requiere tener instalado <em>spell</em>)</li>
  <li>Alt + d :        Contar el número de palabras, líneas y caracteres</li>
</ul>

<h2 id="imprimiendo-ficheros-cat-head-y-tail">Imprimiendo ficheros <em>cat</em>, <em>head</em> y <em>tail</em></h2>

<p>A veces, si los archivos son muy grandes incluso los editores en línea pueden tener problemas para abrirlos.
Otra forma de acceder a los contenidos del fichero sería imprimir el fichero en la terminal utilizando el comando <em>cat</em>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code> ~$ cat microarray_adenoma_hk69.ods
</code></pre>
</div>

<p>Recuerda que las herramientas que estamos viendo sólo sirven para trabjar con ficheros de texto, no binarios.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> ~$ cat microarray_adenoma_hk69.csv
</code></pre>
</div>

<p>Si el archivo es extremadamente largo es posible que la terminal se bloquee durante bastante tiempo (Nota: recuerda que con <em>Crtl + c</em> los programas suelen terminar inmediatamente y se vuelve a mostrar el <em>prompt</em>.</p>

<p><em>cat</em> es además capaz de concatenar textos uno detrás de otro en el orden en que se los pasamos y mostrarlos en pantalla</p>

<div class="highlighter-rouge"><pre class="highlight"><code> ~$ cat file1 file2 file3
</code></pre>
</div>

<p>Algunas opciones interesantes de <em>cat</em> son:</p>

<ul>
  <li>-A : muestra también los caracteres de control, básicamente los tabuladores (como ^I) y los retornos de carro ($)</li>
  <li>-n : numera todas las líneas</li>
</ul>

<p>Para hacernos una idea del contenido del fichero sin bloquear la terminal podemos imprimir tan solo las primeras líneas utilizando el comando <em>head</em>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ head microarray_adenoma_hk69.csv
  "!Exptid=10029"
  "!Experiment Name=Adenoma (HK69)"
  "!Organism=Homo sapiens"
  "!Category=Adenoma"
  "!Subcategory=Liver"
  "!Experimenter=Xin Chen"
  "!Contact email=chenx@pharmacy.ucsf.edu"
  "!Contact Address1=Dept. of Biopharmaceutical Sciences"
  "!Contact Address2=513 Parnassus Ave. S-816"
  "!Contact Address3=Box 0446"
</code></pre>
</div>

<p>Existe otro comando equivalente pero que nos permite imprimir el final de los archivos (<em>tail</em>):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ tail microarray_adenoma_hk69.csv
  24183       "EMPTY" "EMPTY" 19      27      32      0
</code></pre>
</div>

<p>Tanto a <em>head</em> como a <em>tail</em> podemos pedirles que impriman el número de líneas que nosotros deseemos mediante la opción <em>-n</em>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ head -n 2 microarray_adenoma_hk69.csv
  "!Exptid=10029"
  "!Experiment Name=Adenoma (HK69)"
</code></pre>
</div>

<p>Otro comportamiento de <em>tail</em> que resulta útil es que puede mostrar todas las líneas excepto las <em>k</em> primeras líneas. Para ello hay que usar la opción <em>-n</em> y el número de líneas que queremos omitir precedido por un <em>+</em>.
Por ejemplo, para omitir la cabecera del archivo de micro_adenoma que ocupa las primeras 20 líneas podemos hacer:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ tail -n +20 microarray_adenoma_hk69.csv  
</code></pre>
</div>

<h2 id="navegando-por-un-fichero-de-texto">Navegando por un fichero de texto</h2>

<p>En muchas ocasiones para familiarizarnos con el fichero lo mejor es abrirlo y navegar por él.
Podríamos abrir el fichero con un editor de texto, pero ya hemos visto que si es muy grande podríamos tener problemas.
Existe una herramienta capaz de abrir ficheros de texto inmensos sin problemas, <em>less</em>.</p>

<p><em>less</em> es un visor de ficheros de texto, con este programa no podremos editar el fichero, pero sí navegar por su contenido.
<em>less</em> es un programa interactivo por lo que cuando lo ejecutemos se abrirá ocupando el terminal y haciendo desaparecer el <em>prompt</em>.
En cualquier momento podemos salir de <em>less</em> pulsando la tecla “q”.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ less microarray_adenoma_hk69.csv
</code></pre>
</div>

<p>Dentro de <em>less</em> disponemos de varios comandos para movernos por el fichero:</p>

<ul>
  <li>barra de espacio: página siguiente.</li>
  <li>b: página anterior.</li>
  <li>100g: va a la línea 100 (o la que le indiquemos)</li>
  <li>-S: corta o no corta las líneas largas</li>
  <li>/palabra: Busca la cadena de texto que le indiquemos (acepta expresiones regulares)</li>
  <li>n: va a la siguiente palabra que coincide con la búsqueda</li>
  <li>N: va la palabra anterior que coincide con la búsqueda</li>
  <li>
    <p>q: sale del programa</p>
  </li>
  <li>h: ayuda</li>
</ul>

<h2 id="edición-por-línea-de-comandos">Edición por línea de comandos</h2>

<h3 id="wc"><em>wc</em></h3>

<p><em>wc</em> (<em>Word Count</em>) sirve para contar líneas, palabras y caracteres.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ wc leukemia microarray_adenoma_hk69.csv
</code></pre>
</div>

<h3 id="grep"><em>grep</em></h3>

<p>Una tarea que vamos a tener que realizar habitualmente es la de seleccionar diversas líneas en un fichero de texto.
Por ejemplo, imaginemos que queremos saber cual es la expresión de los genes relacionados con la leucemia en el fichero del <em>microarray</em>.
Esto, que en otros sistemas operativos podría resultar bastante complejo de hacer en Unix es trivial:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep leukemia microarray_adenoma_hk69.csv
  3       "IMAGE:302190"  "MLL"   "Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)"
</code></pre>
</div>

<p><em>grep</em> (<em>Generalized Regular Expression Parser</em>) toma un fichero de entrada (o el <em>standard  input</em>) y filtra las líneas que contienen el patrón de búsqueda que le hemos dado. Por defecto incluye en el resultado las líneas que contienen el patrón, pero podríamos pedirle que haga lo contrario utilizando la opción <em>v</em> (<em>inVert</em>).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>~$ grep -v leukemia microarray_adenoma_hk69.csv
  3       "IMAGE:302190"  "MLL"   "Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)"
</code></pre>
</div>

<p><em>grep</em> diferencia entre mayúsculas y minúsculas, pero podemos cambiar este comportamiento con la opción <em>i</em> (ignore case):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>~$ grep -i leukemia microarray_adenoma_hk69.csv
  3       "IMAGE:302190"  "MLL"   "Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)"
</code></pre>
</div>

<p>Si queremos saber en que posiciones del fichero original estaban las líneas que hemos encontrado podemos pedirle que imprima dichos números de línea:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep -n leukemia microarray_adenoma_hk69.csv
</code></pre>
</div>

<p><em>grep</em> puede utilizarse para buscar recursivamente en todos los ficheros contenidos en un directorio.
Por ejemplo podríamos buscar la palabra <em>leukemia</em> en todos los ficheros presentes en alguno de nuestros directorios:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep -r  leukemia ~
</code></pre>
</div>

<p><em>grep</em> tiene otras muchas opciones útiles, en su manual están todas descritas:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ man grep
</code></pre>
</div>

<p><em>grep</em> hace uso de las expresiones regulares que veremos posteriormente por lo que su potencia es mucho mayor que la que ahora podemos imaginar.</p>

<p>Otra de las ventajas de <em>grep</em> viene dada por su adherencia a los principios Unix lo que implica que podemos utilizar <em>grep</em> enlazándolo con otros programas.
Imaginemos que queremos hacer una búsqueda limitada a las primeras cien líneas del fichero, podríamos hacer:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia
</code></pre>
</div>

<p>Lo que hemos hecho es utilizar el comando <em>head</em> para leer las primeras cien líneas del archivo, pero en vez de imprimir el resultado en pantalla hemos redirigido su salida mediante una tubería (<em>pipe</em>) al comando <em>grep</em>.
Éste ha tomado estas cien líneas y las ha filtrado con la palabra <em>leukemia</em>.
Podríamos además redirigir el resultado final a un fichero para guardar el resultado:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia &gt; busqueda_leukemia_100.txt
</code></pre>
</div>

<p>o bien pasárselo a otro programa, por ejemplo, a <em>wc</em> para que cuente el número de veces que aparece <em>leukemia</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia | wc
</code></pre>
</div>

<p>Todos los comandos de manejo de texto que vamos a ver en esta sección tienen esta capacidad.
Todos siguen el principio de realizar una tarea concreta pero teniendo la capacidad de enlazarse con otros.</p>

<h3 id="cut"><em>cut</em></h3>

<p>Cuando el fichero está dividido en campos, como en el caso de la tabla que estamos utilizando, podemos seleccionar alguno de estos campos utilizando el comando <em>cut</em>.
Por ejemplo mejoremos la búsqueda que habíamos hecho quedándonos tan solo con el nombre del gen:</p>

<div class="highlighter-rouge"><pre class="highlight"><code> ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3
 "BAALC"
 "DEK"
</code></pre>
</div>

<p>Con el parámetro <em>-f</em> le indicamos la lista de campos (<em>fields</em>) que queremos seleccionar.</p>

<p>Para indicar los campos que queremos seleccionar:</p>
<ul>
  <li>N	: el campo N (p.e., cut -f 3 file1)</li>
  <li>N- : desde el campo N hasta el final (p.e., cut -f 3- file1)</li>
  <li>N-M : desde el campo N al M (p.e., cut -f 3-6 file1)</li>
  <li>-M : desde el primer campo al campo M (p.e., cut -f -3 file1)</li>
  <li>N,M : los campos indicados (p.e., cut -f 3,6,8 file1)</li>
</ul>

<p>Así podríamos seleccionar los campos del 3 al 5 y del 8 al 10:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ cut -f 3-5,8-10 microarray_adenoma_hk69.csv
</code></pre>
</div>

<p><em>cut</em> asume que los campos en el fichero están divididos por tabuladores.
Pero podríamos indicarle que los campos están divididos de otro modo, por ejemplo por comas:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ cut -d ',' fichero_separado_por_comas.txt
</code></pre>
</div>

<p>Para tener una idea completa de las capacidades ofrecidas por el comando conviene consultar su manual:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ man cut
</code></pre>
</div>

<h3 id="sed"><em>sed</em></h3>

<p>El <em>sed</em> (<em>stream editor</em>) es un editor de texto un tanto especial que toma las líneas de una en una,
les aplica la transformación que le indiquemos y devuelve las líneas modificadas.</p>

<p>Por ejemplo, la lista de genes que hemos obtenido en el apartado anterior puede servirnos para muchos propósitos, pero todavía no está limpia del todo, quedaría mejor si eliminásemos las comillas que rodean los campos:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4 | sed  "s/\"//g"
  BAALC   Brain and acute leukemia, cytoplasmic
  DEK     DEK oncogene (DNA binding)
</code></pre>
</div>

<p>El <em>sed</em> además de sustituir puede realizar cualquier tipo de edición sobre un texto.
La sintaxis utilizada por <em>sed</em> puede resultar algo oscura al principio, pero un mínimo conocimiento de este comando nos permitirá hacer modificaciones en el texto que de otro modo serían muy complejas.</p>

<p>En este curso nos centraremos en el uso del <em>sed</em> para sustituciones. En el ejemplo anterior, el comando sed que hemos utilizado es “s/"//g”.
En primer lugar hemos indicado a <em>sed</em> qué queríamos hacer.
Podemos, como es el caso, substituir un patrón por otro (comando s, sustituir), pero también podríamos pedirle que eliminase líneas (comando d, delete).
Para substituir hay que indicarle qué queremos substituir y por qué:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  s/patrón_a_substituir/nuevo_patrón/
</code></pre>
</div>

<p>En el ejemplo hemos substituido las comillas por nada. En principio deberíamos haber escrito “s/”//”.
Pero dado que las comillas tienen un significado especial en este contexto debemos <em>escaparlas</em>, por eso escribimos “s/\”//”.
Además, a la expresión le hemos añadido una “g”, con este modificador le indicamos a <em>sed</em> que no queremos que substituya sólo la primera aparición del patrón en la línea sino todos los que haya.</p>

<p><em>sed</em> acepta expresiones regulares como patrones y con ellas puede realizar prácticamente cualquier substitución que podamos imaginar.</p>

<h3 id="sort"><em>sort</em></h3>

<p>Si deseamos ordenar alfabéticamente un fichero de texto tan sólo tenemos que utilizar el comando <em>sort</em>.
Por ejemplo, podemos ordenar los genes relacionados con la leucemia:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4| sort
</code></pre>
</div>

<p><em>sort</em> también puede hacer ordenaciones numéricas y puede ordenar por cualquiera de los campos presentes en el fichero.
Para ver qué se puede hacer con <em>sort</em> lo más recomendable es leer su manual.</p>

<h3 id="uniq"><em>uniq</em></h3>

<p>En el ejemplo anterior, al ordenar con <em>sort</em>, hemos visto que en la lista que hemos obtenido hay genes repetidos.
Con el comando <em>uniq</em> podemos eliminar las líneas duplicadas consecutivas.
Para que la eliminación sea completa hay que recordad ordenar con <em>sort</em> antes de utilizar <em>uniq</em>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4| sort | uniq
</code></pre>
</div>

<h3 id="shuf"><em>shuf</em></h3>

<p><em>shuf</em> permite obtener permutaciones aleatorias del archivo de entrada, o bien obtener líneas aleatorias.</p>

<p>Si no le pasamos ningún parámeto a <em>shuf</em> obtendremos permutaciones aleatorias:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ ls / | shuf
</code></pre>
</div>

<p>o bien le podemos pedir el número de líneas aleatorias que deseemos.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4 | shuf -n 5
</code></pre>
</div>

<h2 id="herramientas-para-unir-archivos">Herramientas para unir archivos</h2>

<h3 id="paste"><em>paste</em></h3>

<p><em>paste</em> une ficheros tabulares línea por línea.
Supongamos que tenemos dos ficheros, uno con datos sobre la progresión de la enfermedad de una serie de enfermos y otro con el genotipado de los mismos:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  pacientes:
  id_paciente,nivel_colesterol
  1,190
  2,250
  3,220
  4,260
  5,160
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>  genotipado:
  id_paciente,SNP_a,SNP_b
  1,AA,CC
  2,AC,GG
  3,AA,CG
  4,AT,GG
  5,AA,CC
</code></pre>
</div>
<p>Podemos fusionar los dos archivos usando el comando paste:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ paste -d',' pacientes.txt genotipado.txt
  id_paciente,nivel_colesterol,id_paciente,SNP_a,SNP_b
  1,190,1,AA,CC
  2,250,2,AC,GG
  3,220,3,AA,CG
  4,260,4,AT,GG
  5,160,5,AA,CC
</code></pre>
</div>

<h3 id="join"><em>join</em></h3>

<p><em>join</em> es una herramienta muy potente, pero sencilla. Permite unir dos ficheros de texto en uno usando una columna como clave común. Por defecto, <em>join</em> asume que el separador de campos es el espacio.</p>

<p><em>join</em> es una especie de <em>paste</em> en la que la columna común que sirve como enlace entre ambas tablas no queda duplicada y no requiere que un elemento esté en los dos archivos. <em>join</em> lo que sí que requiere es que ambos archivos estén ordenados por la columna que se queiere usar como clave
Imaginemos que tenemos los dos ficheros siguientes: <a href="./demo_data/file1.txt">file1.txt</a> y <a href="./demo_data/file2.txt">file2.txt</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>  file1.txt:
  num id atributo
  1 abc fff
  2 efg aaa
  5 klm bbb
</code></pre>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>  file2.txt:
  num id atributo
  1 abc ttt
  3 klm fff
  5 opq jjj
  9 rst ttt
</code></pre>
</div>

<p><em>join</em> nos permite unir estas dos tablas en una sola utilizando el campo <em>num</em> como la clave de unión:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ join file1.tx file2.tx
  num id atributo id atributo
  1 abc fff abc ttt
  5 klm bbb opq jjj 
</code></pre>
</div>

<p>Por defecto, <em>join</em> asume que la clave de unión es la primera columna, pero esto se puede modificar:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ join -1 2 -2 2 file1.tx file2.tx
  id num atributo num atributo
  abc 1 fff 1 ttt
  klm 5 bbb 3 fff
</code></pre>
</div>

<p>Las filas que no son comunes entre ambos archivos no se devuelven por defecto, pero esto también es modificable y podemos solicitar que nos devuelva todas las de un archivo, las del otro o las de los dos:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ join -a1 -1 2 -2 2 file1.tx file2.tx
  id num atributo num atributo
  abc 1 fff 1 ttt
  efg 2 aaa
  klm 5 bbb 3 fff
</code></pre>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ join -a1 -a2 -1 2 -2 2 file1.tx file2.tx
  id num atributo num atributo
  abc 1 fff 1 ttt
  efg 2 aaa
  klm 5 bbb 3 fff
  opq 5 jjj
  rst 9 ttt
</code></pre>
</div>

<h2 id="codificación-de-caracteres">Codificación de caracteres</h2>

<p>Los ordenadores codifican los caracteres del lenguaje natural utilizando números.
Los ficheros de texto no son pues más que ficheros de números que el ordenador transforma en caracteres utilizando una tabla de codificación de caracteres antes de imprimirlos.
Una de las tablas de codificación más populares es la <a href="https://es.wikipedia.org/wiki/ASCII">ASCII</a>, en ella se incluyen los caracteres utilizados en la lengua inglesa, pero no los acentos o los caracteres de otros alfabetos.
Para solucionar el problema el ASCII original fue ampliado creándose distintas tablas, una por cada lengua natural.
De este modo con el ASCII correspondiente al castellano podemos crear ficheros de texto con acentos.
Pero al crear distintas tablas de codificación surgió un problema, si nos equivocamos de tabla al decodificar el fichero obtendremos caracteres extraños que no se corresponden con lo que originalmente se había escrito.
Para solucionar el problema se creó la norma <a href="https://es.wikipedia.org/wiki/Unicode">Unicode</a>, que es una gran tabla con unos 100713 símbolos que codifican prácticamente todos los caracteres utilizados en casi cualquier alfabeto humano.</p>

<p>El problema práctico al que nos enfrentamos es que para poder abrir un fichero de texto que incluya caracteres no ingleses debemos conocer la tabla de caracteres en la que fue codificado.
En Linux los ficheros de texto se codifican mediante <em>UTF-8</em> que es una de las tablas del estándar <em>Unicode</em>, pero en <em>Windows</em> no se sigue este estándar.
Las instalaciones de Windows en castellano utilizan la tabla Windows-1252.</p>

<p>Normalmente los editores de texto permiten elegir la tabla de caracteres en la que el fichero ha sido codificado.
Si abrimos un fichero y vemos que tiene símbolos raros lo más normal es que estemos utilizando una tabla de caracteres equivocada.
Este problema también suele ocurrir en las páginas web. Una página web no es más que un fichero de texto con un formato determinado.
Si el navegador no es capaz de inferir la codificación del fichero los acentos pueden aparecer como caracteres extraños.</p>

<p>En Linux hay varios programas que nos permiten cambiar los ficheros de una tabla de codificación a otra, uno de ellos es <em>iconv</em>.
Por ejemplo si tenemos un archivo con una codificación <a href="./demo_data/sagan.utf-8.txt">UTF-8</a> o <a href="./demo_data/sagan.iso-8859-1.txt">ISO-8859-1</a> podemos pasar de una a otra con <em>iconv</em>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ iconv -t ISO-8859-1 -f UTF-8 sagan.iso-8859-1 &gt; sagan.utf-8_mod.txt
  ~$ iconv -f ISO-8859-1 -t UTF-8 sagan.utf-8.txt &gt; sagan.iso-8859-1_mod.txt
</code></pre>
</div>

<h2 id="fin-de-línea">Fin de línea</h2>

<p>Para marcar el final de una línea en un fichero de texto se utiliza un carácter especial.
Por desgracia no ha habido un acuerdo a la hora de decidirse cual es el carácter que debe usarse.
Unix, Windows y Mac OS utilizan caracteres diferentes.
Afortunadamente los editores de texto suelen ser capaces de detectar las tres versiones y muestran el fichero con las líneas que esperamos.
Desgraciadamente el notepad del Windows no es capaz de hacerlo por lo que si abrimos un fichero de texto creado en Linux en el notepad nos aparecerá como una larga línea con símbolos extraños intercalados.
Casi todos los editores de texto permiten hacer el cambio entre los distintos finales de línea.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ unix2dos -n sagan.utf-8.txt sagan.dos.tx
  ~$ cat -A sagan.uft-8.txt
  ~$ cat -A sagan.dos.txt
  ~$ dos2unix sagan.dos.tx
  ~$ cat -A sagan.dos.txt
</code></pre>
</div>

<h2 id="ejercicios">Ejercicios</h2>

<p>Se ha realizado un estudio de un nuevo tratamiento para un linfoma y nos han enviado dos ficheros.
En el llamando <a href="demo_data/cancer_progresion.txt">cancer_progresion.txt</a> se encuentran tanto los datos de los pacientes como el resultado del tratamiento.
En el <a href="demo_data/cancer_ciego.txt">segundo</a> se encuentra la tabla que nos permitirá desentrañar el ensayo del doble ciego, con el identificador de cada paciente y la dosis de droga que se le administró.</p>

<ol>
  <li>
    <p>Sobre el archivo microarray_adenoma_hk69, recupera sólo el primer resultado.</p>
  </li>
  <li>
    <p>¿Cuántos pacientes había en el estudio?</p>
  </li>
  <li>
    <p>¿De cuántos pacientes no tenemos datos de progresión?</p>
  </li>
  <li>
    <p>Convertir la separación de comas de la tabla de doble ciego a tabuladores (el tabulador se escribe como \t).</p>
  </li>
  <li>
    <p>Unir la tabla de los resultados de la terapia con la del doble ciego.</p>
  </li>
  <li>
    <p>Transformar el fichero resultante las comas a tabuladores.</p>
  </li>
  <li>
    <p>¿Cómo les ha ido a los pacientes según el tipo de tratamiento? (Placebo está escrito con mayúsculas y minúsculas)</p>
  </li>
  <li>
    <p>Crea un fichero con los primeros 100 resultados del microarray de adenoma que incluya sólo las primeras 10 columnas.</p>
  </li>
  <li>
    <p>Ordena el fichero micro.txt generado en la cuestión 7 por el nombre del gen (campo 3) y por el id de la fila, pero en orden numérico reverso.</p>
  </li>
  <li>
    <p>Disponemos de dos ficheros con secuencias de ADN: <a href="demo_data/seqs_1.fasta">seqs_1.fasta</a> y <a href="demo_data/seqs_2.fasta">seqs_2.fasta</a> ¿Cuántas secuencias hay en cada fichero? ¿Hay alguna secuencia presente en ambos ficheros? (En los archivos de secuencia tipo fasta el nombre de las secuencias se encuentra en las líneas que comienzan por el símbolo <em>&gt;</em>)</p>
  </li>
  <li>
    <p>Disponemos de un fichero con <a href="demo_data/seqs_3.fasta">secuencia de ADN</a>, puedes extraer los nombres de las sequencias?</p>
  </li>
  <li>
    <p>Disponemos de un fichero con el resultado de un mapeo en <a href="demo_data/tomate.sam">formato SAM</a> ¿Cuntas secuencias se han mapeado? ¿Cuántas se han mapeado en dirección reversa (mirad la segunda columna: 0 forward; 16 reverse)? ¿Cuántos y cuáles son los unigenes a los que se ha podido mapear alguna secuencia? Ordena las nombres de secuencias mapeadas con el orden del unigene y la posición en el unigene.</p>
  </li>
</ol>

<h2 id="soluciones">Soluciones</h2>

<p>1.- Sobre el archivo microarray_adenoma_hk69, recupera sólo el primer resultado.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ tail -n +21 microarray_adenoma_hk69.csv | head -1
</code></pre>
</div>

<p>2.- ¿Cuántos pacientes había en el estudio?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep -v nombre cancer_progresion.txt | wc -l
  11
</code></pre>
</div>

<p>3.- ¿De cuántos pacientes no tenemos datos de progresión?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep  desconocido cancer_progresion.txt  | wc -l
  1
</code></pre>
</div>

<p>4.- Convertir la separación de comas de la tabla de doble ciego  a tabuladores.
   (El tabulador se escribe como \t)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ sed -e 's/,/\t/' cancer_ciego.txt &gt; cancer_ciego_tab.txt
</code></pre>
</div>

<p>5.- Unir la tabla de los resultados de la terapia con la del doble ciego.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ join cancer_progresion.txt cancer_ciego_tab.txt &gt; cancer.txt
</code></pre>
</div>

<p><em>join</em>, por defecto, crea la nueva tabla usando como separador los espacios.
Para poder hacerlo correctamente con tabuladores habría que usar “join -t $’\t’”.
Otro modo correcto y más sencillo de hacerlo sería pasar antes todos los tabuladores a comas y hacerlo con comas.
Estas herramientas tienen este tipo de limitaciones, más adelante con Python podremos superarlas fácilmente.</p>

<p>6.- Transformar el fichero resultante los espacios a tabuladores.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ sed -e 's/ /\t/g' cancer.txt
</code></pre>
</div>

<p>7.- ¿Cómo les ha ido a los pacientes según el tipo de tratamiento? (Placebo está escrito con mayúsculas y minúsculas)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep -i placebo cancer.txt
  1 Pepe Granada buena placebo
  4 Mónica Madrid mala placebo
  7 Óscar Barcelona mala Placebo
  10 Jordi Barcelona mala Placebo
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep -i 1mg cancer.txt
  2 Juan Lugo muy buena 1mg
  3 Alicia Valencia muy buena 1mg
  8 Trini Valencia muy buena 1mg
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep -i 2mg cancer.txt
  5 Alberto Madrid regular 2mg
  6 Toni Toledo mala 2mg
  9 Pepe Valencia buena 2mg
  11 Manolo Sevilla desconocido 2mg
</code></pre>
</div>

<p>8.- Crea un fichero con los primeros 100 resultados del microarray de adenoma que incluya sólo las primeras 10 columnas.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep -v '^"' microarray_adenoma_hk69.csv | head -n 100 | cut -f 1-10 &gt; micro.txt
</code></pre>
</div>

<p>9.- Ordena el fichero micro.txt generado en la cuestión 7 por el nombre del gen (campo 3) y por el id de la fila, pero en orden numérico reverso.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ sort -k 3 micro.txt
  ~$ sort -nr micro.txt
</code></pre>
</div>

<p>10.- Disponemos de dos ficheros con secuencias de ADN (seqs_1.fasta y seqs_2.fasta). ¿Cuántas secuencias hay en cada fichero? ¿Hay alguna secuencia presente en ambos ficheros? (En los archivos de secuencia tipo fasta el nombre de las secuencias se encuentra en las líneas que comienzan por el símbolo <em>&gt;</em>)</p>

<p>Veamos cuantas secuencias hay en cada archivo y después contemos las secuencias no repetidas que hay en un archivo que las incluya a todas.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ cat seqs_1.fasta | grep '&gt;' | wc -l
  11
  ~$ cat seqs_2.fasta | grep '&gt;' | wc -l
  11
  ~$ cat seqs_1.fasta seqs_2.fasta | grep '&gt;' | sort | uniq | wc -l
  20
</code></pre>
</div>

<p>Sí hay secuencias repetidas puesto que cuando las contamos todas juntas hay dos menos que cuando las contamos por separado.
Podemos ver qué secuencias hay repetidas utilizando el parámetro <em>-d</em> del uniq:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ cat seqs_1.fasta seqs_2.fasta | grep '&gt;' | sort | uniq -d
  &gt;gi|311207420|gb|GT728904.1|GT728904
  &gt;gi|311210057|gb|GT715712.1|GT715712
</code></pre>
</div>

<p>Efectivamente ambas secuencias se encuentran repetidas en los dos ficheros:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep '&gt;gi|311207420|gb|GT728904.1|GT728904' seqs_1.fasta
  &gt;gi|311207420|gb|GT728904.1|GT728904
  $ grep '&gt;gi|311207420|gb|GT728904.1|GT728904' seqs_2.fasta
  &gt;gi|311207420|gb|GT728904.1|GT728904
</code></pre>
</div>

<p>11.- Para poder extraer los nombres conviene primero echar un vistazo al fichero para ver que contiene.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep "&gt;" seqs_3.fasta|cut -c 2- | cut -f 1 -d " "
</code></pre>
</div>

<p>12.-</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ~$ grep -v "^@" tomate.sam | wc
  ~$ grep -v "^@" tomate.sam | cut -f 2 | grep 16 | wc
  ~$ grep -v "^@" tomate.sam | cut -f 3 | sort -u
  ~$ grep -v "^@" tomate.sam | sort -k 3,4 |cut -f 1
</code></pre>
</div>

<h2 id="bibliografía">Bibliografía</h2>

<ul>
  <li>Chris Herborth, <a href="http://www.ibm.com/developerworks/aix/library/au-textprocess.html">Text processing with UNIX</a></li>
  <li>TDLP, <a href="http://tldp.org/LDP/abs/html/textproc.html">Text Processing Commands</a></li>
</ul>

  </div>

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Curso Unix</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Curso Unix
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Introduction to the Linux command line.</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
