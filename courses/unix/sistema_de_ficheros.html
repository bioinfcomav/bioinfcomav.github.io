
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>El sistema de ficheros &mdash; Bioinformatics at COMAV 0.1 documentation</title>
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sphinx_highlight.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="Bioinformatics at COMAV 0.1 documentation" href="index.html" />
    <link rel="next" title="Control de procesos" href="control_procesos.html" />
    <link rel="prev" title="Unix y Linux" href="unix_intro.html" /> 
  </head>
  <body>

<div class="body">
    <header>
        <h1><a href="index.html">Bioinformatics at COMAV</a></h1>
    </header>


    <nav class="horizontal_nav page_nav">
        <ul>
            <li><a href="/index.html">Bioinformatics & genomics</a>
                <ul>
                    <li><a href="/services.html">Services</a></li>
                    <li><a href="/people.html">People</a></li>
                    <li><a href="/publications.html">Publications</a></li>
                    <li><a href="/getting_here.html">Getting here</a></li>
<!--                    <li><a href="http://bioinf.comav.upv.es/notes/">Wiki</a></li>-->
               </ul>
            </li>
            <li><a href="/software.html">Software</a>
                <ul>
                    <li><a href="https://github.com/bioinfcomav/">Bioinf COMAV</a></li>
                    <li><a href="https://github.com/JoseBlanca/">Jose Blanca</a></li>
                    <!--
                    <li><a href="/seq_crumbs/index.html">seq_crumbs</a></li>
                    <li><a href="/ngs_backbone/index.html">ngs_backbone</a></li>
                    <li><a href="/clean_reads/index.html">clean_reads</a></li>
                    <li><a href="/sff_extract/index.html">sff_extract</a></li>
                    <li><a href="/psubprocess/index.html">psubprocess</a></li>-->
               </ul>
            </li>
            <li><a href="/courses.html">Courses</a>
                <ul>
                    <li><a href="/courses/intro_bioinf/index.html">Bionformática básica</a></li>
                    <li><a href="/courses/sequence_analysis/index.html">NGS sequence analysis</a></li>
                    <li><a href="/courses/linux/index.html">Linux y Python</a></li>
                    <li><a href="/courses/unix/index.html">Linux para Biologos</a></li>
               </ul>
        </ul>
    </nav>

    <main>
                
    
  <section id="el-sistema-de-ficheros">
<h1>El sistema de ficheros<a class="headerlink" href="#el-sistema-de-ficheros" title="Permalink to this heading">¶</a></h1>
<p>El <a class="reference external" href="https://en.wikipedia.org/wiki/File_system">sistema de archivos</a> controla como se almacenan los archivos en el ordenador.
Sus dos tareas principales son guardar y leer archivos previamente guardados.</p>
<section id="sistemas-jerarquicos">
<h2>Sistemas jerárquicos<a class="headerlink" href="#sistemas-jerarquicos" title="Permalink to this heading">¶</a></h2>
<p>Los sistemas de archivos suelen tener <a class="reference external" href="https://en.wikipedia.org/wiki/Directory_(computing">directorios</a>) en los que organizar los archivos y estos directorios suelen estar organizados jerárquicamente.
La jerarquía implica que un directorio puede contener subdirectorios.
El directorio más alto en la jerarquía del que cuelgan todos los demás se denomina <em>raíz</em> (root).
En los sistemas Unix el directorio raíz se representa con una barra “<em>/</em>“ y sólo existe una jerarquía, es decir, sólo existe un directorio raíz, incluso aunque haya distintos discos duros en el ordenador.</p>
<p>Dentro del directorio raíz podemos encontrar diversos subdirectorios, por ejemplo en Linux existe el directorio <em>home</em>.
<em>home</em> es por tanto un subdictorio del directorio raíz.
Esta relación se representa como:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">home</span>
</pre></div>
</div>
<p><em>home</em> es el directorio dónde se encuentran los directorios de los usuarios en un sistema Linux.
Imaginemos que tiene los subdirectorios <em>alicia</em> y <em>juan</em>.
Se representaría como:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">alicia</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">juan</span>
</pre></div>
</div>
<p>Existe un estándar, denominado <a class="reference external" href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">Filesystem Hierarchy Standard</a> que define la estructura de directorios de los sistemas Unix.
Los sistemas Unix suelen seguir este estándar, aunque a veces lo violan en algunos aspectos.
Por ejemplo en MacOS X el directorio donde se encuentran los direcotorios de los usuarios se denomina <em>Users</em> y no <em>home</em></p>
<p>En algunos sistemas operativos no UNIX la barra se escribe al revés “&quot;, a pesar de que la convención siempre fue la contraria.</p>
<p>En el directorio raíz hay diversos directorios que, en la mayoría de los casos, sólo deberían interesarnos si estamos administrando el ordenador.
Los usuarios normalmente sólo escriben dentro de un directorio de su propiedad localizado dentro de /home y denominado como su nombre de usuario.</p>
<p>Los usuarios también pueden escribir en /tmp aunque normalmente son los procesos lanzados por estos lo que hacen esta escritura.
Es importante revisar el espacio libre en la partición en la que se encuentra /tmp para que no se colapse el sistema.
Recuerda que /tmp es borrado habitualmente por el sistema. Normalmente con cada nuevo arranque.</p>
</section>
<section id="rutas-absolutas-relativas-y-directorio-de-trabajo">
<h2>Rutas absolutas, relativas y directorio de trabajo<a class="headerlink" href="#rutas-absolutas-relativas-y-directorio-de-trabajo" title="Permalink to this heading">¶</a></h2>
<p>Para referirnos a un archivo o a un directorio debemos indicar su ruta (<a class="reference external" href="https://en.wikipedia.org/wiki/Path_(computing">path</a>).
Un ejemplo de ruta podría ser:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">alicia</span><span class="o">/</span><span class="n">documentos</span><span class="o">/</span><span class="n">tesis</span><span class="o">.</span><span class="n">md</span>
</pre></div>
</div>
<p>Este tipo de rutas en las que se especifican todos los subdirectorios empezando desde el directorio raíz se denominan rutas absolutas.</p>
<p>Para no tener que escribir la ruta absoluta completa cada vez que queremos referirnos a un archivo o a un directorio se crearon los conceptos de <a class="reference external" href="https://en.wikipedia.org/wiki/Working_directory">directorio de trabajo</a> y de <a class="reference external" href="https://en.wikipedia.org/wiki/Path_(computing">ruta relativa</a>#Absolute_and_relative_paths).</p>
<p>El directorio de trabajo es una propiedad del terminal (del shell) en la que estamos trabajando.
Siempre que estemos trabajando en una terminal tendremos asignado un directorio de trabajo.
Por ejemplo, si nuestro usuario es <em>alicia</em> sería normal que al abrir un terminal nuestro directorio de trabajo fuese:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">alicia</span>
</pre></div>
</div>
<p>El directorio de trabajo se utiliza para escribir rutas a archivos relativas al mismo.
De este modo nos ahorramos escribir bastante.
Imaginemos que Alicia tiene en su directorio un documento llamado peliculas.txt.
La ruta absoluta sería.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">alicia</span><span class="o">/</span><span class="n">peliculas</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>Mientras su directorio de trabajo sea /home/alicia la ruta relativa sería simplemetne:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">peliculas</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>Es decir, podemos escribir rutas relativas al directorio de trabajo, rutas que en vez de partir del directorio raíz parten desde el directorio de trabajo.
Las rutas relativas se diferencian de las absolutas en los sistemas Unix porque las absolutas empiezan por “y” las relativas no.</p>
<p>Es común referirse al directorio de trabajo de una terminal como a un lugar en el que nos encontramos mientras estamos trabajando en la terminal.
Siempre que estemos en una terminal estaremos dentro de un directorio de trabajo.</p>
<p>Por ejemplo, cuando abrimos un nuevo terminal el directorio de trabajo se sitúa en /home/nombre_de_usuario.
Si ejecutamos el comando <em>ls</em>, el programa asumirá que queremos listar los archivos presentes en ese directorio y no en otro cualquiera.
Existe un comando que nos informa sobre el directorio de trabajo actual, pwd (Print Working Directory):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pwd
/home/alicia
</pre></div>
</div>
<p>Si deseamos podemos modificar el directorio de trabajo “moviéndonos” a otro directorio.
Para lograrlo hay que utilizar el comando <em>cd</em> (Change Directory):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd documentos
$ pwd
/home/alicia/documentos
</pre></div>
</div>
<p>A partir de ese momento los comandos asumirán que si no se les indica lo contrario el directorio desde el que deben trabajar es /home/alicia/documentos.</p>
<p><em>cd</em> además tiene algunos parámetros especiales:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd      Ir al directorio $HOME del usuario.
cd -    Ir al directorio de trabajo previo
</pre></div>
</div>
</section>
<section id="directorio-home">
<h2>Directorio $HOME<a class="headerlink" href="#directorio-home" title="Permalink to this heading">¶</a></h2>
<p>El directorio $HOME en los sistemas Unix, que son sistemas multiusuario, es el directorio en el que el usuario debe mantener sus ficheros y directorios.
Fuera de este directorio el usuario tendrá unos permisos restringidos puesto que sus acciones podrían afectar a otros usuarios.</p>
<p>En Linux los directorios $HOME de los usuarios son subdirectorios del directorio <em>/home</em>.</p>
<p>El directorio $HOME de un usuario es además el directorio de trabajo por defecto, es decir, el directorio de trabajo que se establece cuando se abre una terminal.</p>
</section>
<section id="moviendo-renombrando-y-copiando-ficheros">
<h2>Moviendo, renombrando y copiando ficheros<a class="headerlink" href="#moviendo-renombrando-y-copiando-ficheros" title="Permalink to this heading">¶</a></h2>
<p>En primer lugar vamos a crear un fichero de prueba:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ touch data.txt
~$ ls
data.txt
</pre></div>
</div>
<p>El comando <em>touch</em>, en este caso, ha creado un fichero vacío.</p>
<p>Los ficheros se copian con el comando <em>cp</em> (CoPy):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cp data.txt data.bak.txt
~$ ls
data.bak.txt  data.txt
</pre></div>
</div>
<p>Se mueven y renombran con el <em>mv</em> (MoVe):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ mv data.txt experimento_1.txt
~$ ls
data.bak.txt  experimento_1.txt
</pre></div>
</div>
<p>Para crear un nuevo directorio podemos utilizar la orden <em>mkdir</em> (MaKeDIRectory):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ mkdir exp_1
~$ ls
data.bak.txt  exp_1  experimento_1.txt
</pre></div>
</div>
<p><em>mv</em> también sirve para mover ficheros entre directorios:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ mv experimento_1.txt exp_1/
~$ ls
data.bak.txt  exp_1
~$ ls exp_1/
experimento_1.txt
</pre></div>
</div>
<p>Los ficheros se eliminan con la orden <em>rm</em> (ReMove):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ rm data.bak.txt
~$ ls
exp_1
</pre></div>
</div>
<p>En la línea de comandos de los sistemas Unix cuando se borra un fichero se borra definitivamente, no hay papelera.
Una vez ejecutado el <em>rm</em> no podremos recuperar el archivo.</p>
<p>Los comandos <em>cp</em> y <em>rm</em> no funcionarán bien con los directorios a no ser que modifiquemos el comportamiento que muestran por defecto:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ rm exp_1/
rm: cannot remove exp_1/ Is a directory
~$ cp exp_1/ exp_1_bak/
cp: omitting directory exp_1/
</pre></div>
</div>
<p>Esto sucede porque para copiar o borrar un directorio hay que copiar o borrar todos sus contenidos recursivamente y esto podría alterar muchos datos con un sólo comando.
Por esta razón se exige que estos dos comandos incluyan un modificador que les indique que sí deben funcionar recursivamente cuando tratan con directorios:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ cp -r exp_1/ exp_1_bak/
~$ ls
exp_1  exp_1_bak
~$ rm -r exp_1_bak/
~$ ls
exp_1
</pre></div>
</div>
</section>
<section id="nombres-de-directorios-y-archivos">
<h2>Nombres de directorios y archivos<a class="headerlink" href="#nombres-de-directorios-y-archivos" title="Permalink to this heading">¶</a></h2>
<p>En Unix los archivos pueden tener prácticamente cualquier nombre.
Existe la convención de acabar los nombres con un punto y una pequeña extensión que indica el tipo de archivo.
Pero esto es sólo una convención, en realidad podríamos no utilizar este tipo de nomenclatura.</p>
<p>Si deseamos utilizar nombres de archivos que no vayan a causar extraños comportamientos en el futuro lo mejor sería seguir unas cuantas reglas al nombrar un archivo:</p>
<ul class="simple">
<li><p>Añadir una extensión para recordarnos el tipo de archivo, por ejemplo .txt para los archivos de texto.</p></li>
<li><p>No utilizar en los nombres:</p>
<ul>
<li><p>espacios,</p></li>
<li><p>caracteres no alfanuméricos,</p></li>
<li><p>ni caracteres no ingleses como letras acentuadas o eñes.</p></li>
</ul>
</li>
</ul>
<p>Por supuesto, podríamos crear un archivo denominado “$ñ 1.txt” para referirnos a un archivo de sonido, pero esto conllevaría una sería de problemas que aunque son solventables nos dificultarán el trabajo.</p>
<p>Además es importante recordar que en Unix las mayúsculas y las minúsculas no son lo mismo.
Los ficheros “documento.txt”, “Documento.txt” y “DOCUMENTO.TXT” son tres ficheros distintos.</p>
<p>Otra convención utilizada en los sistema Unix es la de ocultar los archivos cuyos nombres comienzan por punto “.”.
Por ejemplo el archivo “.oculto” no aparecerá normalmente cuando pedimos el listado de un directorio.
Esto se utiliza normalmente para guardar archivos de configuración que no suelen ser utilizados directamente por los usuarios.
Para listar todos los archivos (All), ya sean éstos ocultos o no se puede ejecutar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ls -a
.               .fontconfig          .HyperTree           .pki
..               fsm.jpg              .ICEauthority        .recently-used
</pre></div>
</div>
<p>Esta convención de ocultar los ficheros cuyo nombre comienza por un punto se mantiene también en el navegador gráfico de ficheros.
En este caso podemos pedir que se muestren estos archivos en el menú Ver -&gt; Mostrar los archivos ocultos.</p>
<p>Para acelerar el acceso a ciertos directorios existen algunos nombres especiales que son bastante útiles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* &quot;..&quot; indica el directorio padre del directorio actual
* &quot;.&quot; indica el directorio actual
* &quot;~&quot; representa la $HOME del usuario
</pre></div>
</div>
</section>
<section id="wildcards">
<h2>WildCards<a class="headerlink" href="#wildcards" title="Permalink to this heading">¶</a></h2>
<p>En muchas ocasiones resulta útil tratar los ficheros de un modo conjunto.
Por ejemplo, imaginemos que queremos mover todos los ficheros de texto a un directorio y la imágenes a otro.
Creemos una pequeña demostración:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ touch exp_1a.txt
~$ touch exp_1b.txt
~$ touch exp_1b.jpg
~$ touch exp_1a.jpg
~$ ls
exp_1  exp_1a.jpg  exp_1a.txt  exp_1b.jpg  exp_1b.txt
</pre></div>
</div>
<p>Podemos referirnos a todos los archivos que acaban en txt utilizando un asterisco:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ mv *txt exp_1
~$ ls
exp_1  exp_1a.jpg  exp_1b.jpg
</pre></div>
</div>
<p>El asterisco sustituye a cualquier texto, por lo que al escribir <em>txt</em> incluimos a cualquier fichero que tenga un nombre cualquiera, pero que termine con las letras txt.
Podríamos por ejemplo referirnos a los ficheros del experimento 1a:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ ls *1a*
exp_1a.jpg
</pre></div>
</div>
<p>Esta herramienta es muy potente y útil, pero tenemos que tener cuidado con ella, sobre todo cuando la combinamos con <em>rm</em>.
Por ejemplo la orden:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ rm -r *
</pre></div>
</div>
<p>Borraría todos los ficheros y directorios que se encuentren bajo el directorio de trabajo actual, si lo hacemos perderemos todos los ficheros y directorios que cuelgan del actual directorio de trabajo, puede que esto sea lo que queramos, pero hemos de andar con cuidado.</p>
</section>
<section id="ejercicios">
<h2>Ejercicios<a class="headerlink" href="#ejercicios" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>¿Cuáles son los ficheros y directorios presentes en el directorio raíz?</p></li>
<li><p>¿Cuáles son todos los archivos presentes en nuestro directorio de usuario?</p></li>
<li><p>Crea un directorio llamado experimento.</p></li>
<li><p>Crea con touch los archivos datos1.txt y datos2.txt dentro del directorio experimento.</p></li>
<li><p>Vuelve al directorio principal de tu usuario y desde allí lista los archivos presentes en el directorio experimento usando rutas absolutas y relativas</p></li>
<li><p>Haz del directorio ~/Documentos tu directorio de trabajo y repite el ejercicio anterior</p></li>
<li><p>Borra todos los archivos que contengan un 2 en el directorio experimento.</p></li>
<li><p>Copia el directorio experimento a un nuevo directorio llamado exp_seguridad.</p></li>
<li><p>Borra el directorio experimento.</p></li>
<li><p>Renombra el directorio exp_seguridad a experimento.</p></li>
<li><p>Copia el fichero /etc/passwd al directorio ~/Documentos</p></li>
<li><p>Copia el fichero /etc/passwd al directorio ~/Documentos llamándolo usuarios.txt</p></li>
</ol>
</section>
<section id="obteniendo-informacion-sobre-archivos-y-directorios">
<h2>Obteniendo información sobre archivos y directorios<a class="headerlink" href="#obteniendo-informacion-sobre-archivos-y-directorios" title="Permalink to this heading">¶</a></h2>
<p><em>ls</em> es un comando capaz de mostrarnos información extra sobre los archivos y directorios que lista.
Por ejemplo podemos pedirle, usando la opción <em>-l</em> (Long),  que nos muestre quién es el dueño del archivo y cuanto ocupa y qué permisos tiene además de otras cosas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ ls
exp_1
~$ ls -l
total 4
drwxr-xr-x 2 usuario usuario 4096 Oct 13 09:48 exp_1
</pre></div>
</div>
<p>La información sobre la cantidad de disco ocupada la da por defecto en bytes, si la queremos en un formato más inteligible podemos utilizar la opción <em>-h</em> (Human):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ ls -lh
total 4.0K
drwxr-xr-x 2 usuario usuario 4.0K Oct 13 09:48 exp_1
</pre></div>
</div>
<p>Podemos consultar el tipo de un archivo mediante el comando <em>file</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ file imagen.png
imagen.png: PNG image data, 1920 x 1080, 8-bit/color RGB, non-interlaced
</pre></div>
</div>
<p>En principio, el tipo de un archivo no está determinado por la extensión, la extensión es sólo parte del nombre, aunque hay software que viola o complementa este principio.
El tipo de archivo está determinado por su <a class="reference external" href="https://en.wikipedia.org/wiki/Magic_number_(programming">magic number</a>).
El magic number está compuesto por una corta <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_file_signatures">serie de bytes</a> que indican el tipo de archivo.</p>
</section>
<section id="permisos">
<h2>Permisos<a class="headerlink" href="#permisos" title="Permalink to this heading">¶</a></h2>
<p>Unix desde su origen ha sido un sistema multiusuario.
Para conseguir que cada usuario pueda trabajar en sus archivos, pero que no pueda interferir accidental o deliberadamente con los archivos de otros usuarios se estableció desde el principio un sistema de permisos.
Por defecto un usuario tiene permiso para leer y modificar sus propios archivos y directorios, pero no los de los demás.
En los sistemas Unix los ficheros pertenecen a un usuario concreto y existen unos permisos diferenciados para este usuario y para el resto.
Además el usuario pertenece a un grupo de trabajo.
Por ejemplo, imaginemos que la usuaria alicia puede pertenecer al grupo de trabajo “diagnostico”.
Si alicia crea un fichero este tendrá unos permisos diferentes para alicia, para el resto de miembros de su grupo y para el resto de usuarios del ordenador.
Podemos ver los permisos asociados a los ficheros utilizando el comando <em>ls</em> con la opción -l (Long):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~$ ls -l
total 7324
-rw-r--r-- 1 alicia diagnostico    1059 Oct 20 12:42 busqueda_leukemia_100.txt
-rw-r--r-- 1 alicia diagnostico       0 Oct 13 10:53 datos_1.txt
drwxr-xr-x 2 alicia diagnostico    4096 Oct 13 10:29 experimento
</pre></div>
</div>
<p>En este caso, los ficheros listados pertenecen Alicia y al grupo diagnostico.
Los permisos asignados al usuario, a los miembros del grupo y al resto de usuarios están resumidos en la primeras letras de cada línea:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">drwxr</span><span class="o">-</span><span class="n">x</span><span class="o">---</span>
</pre></div>
</div>
<p>La primera letra indica el tipo de fichero listado: (d) directorio, (-) fichero u otro tipo especial.
Las siguientes nueve letras muestran, en grupos de tres, los permisos para el usuario, para el grupo y para el resto de usuarios del ordenador.
Cada grupo de tres letras indica los permisos de lectura (Read), escritura (Write) y ejecución (eXecute).
En el caso anterior el usuario tiene permiso de lectura, escritura y ejecución (rwx), el grupo tiene permiso de lectura y ejecución (r-x), es decir no puede modificar el fichero o el directorio, y el resto de usuarios no tienen ningún permiso (—).</p>
<p>En los ficheros normales el permiso de lectura indica si el fichero puede ser leído, el de escritura si puede ser modificado y el de ejecución si puede ser ejecutado.
En el caso de los directorios el de escritura indica si podemos añadir o borrar ficheros del directorio y el de ejecución si podemos listar los contenidos del directorio.</p>
<p>Estos permisos pueden ser modificados con la orden <em>chmod</em>.
En chmod cada grupo de usuarios se representa por una letra:</p>
<ul class="simple">
<li><p>u: usuario dueño del fichero</p></li>
<li><p>g: grupo de usuarios del dueño del fichero</p></li>
<li><p>o: todos los otros usuarios</p></li>
<li><p>a: todos los tipos de usuario (dueño, grupo y otros)</p></li>
</ul>
<p>Los tipos de permisos también están abreviados por letras:</p>
<ul class="simple">
<li><p>r: lectura</p></li>
<li><p>w: escritura</p></li>
<li><p>x: ejecución</p></li>
</ul>
<p>Con estas abreviaturas podemos modificar los permisos existentes.</p>
<p>Hacer un fichero ejecutable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chmod u+x
</pre></div>
</div>
<p>O:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chmod a+x
</pre></div>
</div>
<p>También podemos mediante chmod indicar los permisos para un tipo de usuario determinado.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chmod a=rwx
</pre></div>
</div>
<p>Un modo algo menos intuitivo, pero más útil de utilizar chmod es mediante los números octales que representan los permisos.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">lectura</span><span class="p">:</span> <span class="mi">4</span>
<span class="o">-</span> <span class="n">escritura</span><span class="p">:</span> <span class="mi">2</span>
<span class="o">-</span> <span class="n">ejecución</span><span class="p">:</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Para modificar los permisos de este modo debemos indicar el número octal que queremos que represente los permisos del fichero.
La primera cifra representará al dueño, la segunda al grupo y la tercera al resto de usuarios.
Por ejemplo si queremos que único permiso para el dueño y su grupo sea la lectura y que no haya ningún permiso para el resto de usuarios:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chmod 110 fichero.txt
</pre></div>
</div>
<p>También podemos combinar permisos sumando los números anteriores.
Por ejemplo, permiso para leer y escribir para el dueño y ningún permiso para el resto.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chmod 300 fichero.txt
</pre></div>
</div>
<p>Permisos de lectura, escritura y ejecución para el dueño y su grupo y ninguno para el resto.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chmod 770 fichero.txt
</pre></div>
</div>
<p>Las restricciones para los permisos no afectan al usuario root, al administrador del sistema.
root también puede modificar quien el dueño y el grupo al que pertenecen los ficheros mediante los comando chown y chgrp.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chown alicia fichero.txt
$ chown diagnostico fichero.txt
</pre></div>
</div>
</section>
<section id="obteniendo-informacion-sobre-el-sistema-de-archivos">
<h2>Obteniendo información sobre el sistema de archivos<a class="headerlink" href="#obteniendo-informacion-sobre-el-sistema-de-archivos" title="Permalink to this heading">¶</a></h2>
<p>El sistema de archivos puede abarcar una o más <a class="reference external" href="https://en.wikipedia.org/wiki/Disk_partitioning">particiones</a>.
Una partición es una región de un disco o de cualquier otro medio de almacenamiento.
Las instalaciones de Windows tienen normalmente una partición por disco, pero en Linux esto no es tan habitual.
Cada partición tiene un sistema de archivos propio, pero en Unix estos sistemas deben estar montados en algún lugar dentro de la jerarquía que cuelga de la raíz.
En Windows cada partición tiene por defecto una jerarquía independiente.</p>
<p>Podemos pedir información sobre el espacio ocupado por las distintas particiones que tenemos actualmente montadas usando el comando <em>df</em> (Disk Free).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ df -h
S.ficheros     Tamaño Usados  Disp Uso% Montado en
udev             7,8G      0  7,8G   0% /dev
tmpfs            1,6G   9,8M  1,6G   1% /run
/dev/nvme0n1p2    25G   8,1G   16G  35% /
tmpfs            7,8G   5,3M  7,8G   1% /dev/shm
tmpfs            5,0M   4,0K  5,0M   1% /run/lock
tmpfs            7,8G      0  7,8G   0% /sys/fs/cgroup
/dev/nvme0n1p4   206G    18G  178G   9% /home
/dev/nvme0n1p1   511M   3,6M  508M   1% /boot/efi
/dev/sda1        2,7T   117G  2,5T   5% /home/jose/magnet
tmpfs            1,6G    64K  1,6G   1% /run/user/1000
</pre></div>
</div>
<p>Algunos de los sistemas de archivos montados puede que no se correspondan con particiones en un disco físico sino con espacios de la memoria RAM que son utilizados como sistemas de archivos especiales.</p>
<p>El commando <em>du</em> (disk usage) informa sobre el espacio que ocupa un árbol de directorios.
Este comando tiene equivalentes gráficos como Baobab o xdiskusage.
Podemos pedir a <em>du</em> que nos muestre cuanto espacio ocupan los directorios bajo el directorio analysis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ du -h analyses/
36K analyses/alicia/cache
204K    analyses/alicia/differential_snps/differential
252K    analyses/alicia/differential_snps/non_differentia
919M    analyses/
</pre></div>
</div>
<p>Si sólo queremos obtener el resultado para el directorio que le hemos dado y no para sus subdirectorios podemos utilizar el parámetro <em>-s</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ du -sh analyses/
919M    analyses/
</pre></div>
</div>
<p>Si queremos información sobre todos los archivos y no sólo los directorios podemos usar <em>-a</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ du -ha analyses/
32K analyses/alicia/cache/min_called_rate_samples_cache.pickle
36K analyses/alicia/cache
8,0K    analyses/alicia/look_for_matching_accessions.py
</pre></div>
</div>
<section id="id1">
<h3>Ejercicios<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>¿Cuáles son los permisos de los directorios presentes en el directorio raíz y en nuestro directorio de usuario? ¿A quién pertenecen los ficheros y qué permisos tienen los distintos usuarios del ordenador?</p></li>
<li><p>Crea un directorio en tu home y muestra los permisos que tiene.</p></li>
<li><p>Cambia los permisos para que sólo tu usuario pueda acceder al nuevo directorio</p></li>
<li><p>Crea un fichero nuevo y dale permisos de ejecución para todos los usuarios</p></li>
<li><p>Último fichero modificado en el directorio /etc.</p></li>
<li><p>Lista los ficheros de /etc con su tamaño y ordénalos por tamaño.</p></li>
<li><p>Copia todos los ficheros y directorios del directorio /etc cuyo nombre comience por s. ¿Has podido copiarlos todos?</p></li>
<li><p>¿Cuánto espacio libre queda en las distintas particiones del sistema?</p></li>
<li><p>¿Cuánto espacio ocupan todos los ficheros y subdirectorios de tu $HOME?</p></li>
</ol>
</section>
</section>
<section id="compresion-y-descompresion-de-ficheros">
<h2>Compresion y descompresión de ficheros<a class="headerlink" href="#compresion-y-descompresion-de-ficheros" title="Permalink to this heading">¶</a></h2>
<p>Existen distintos formatos de compresión de ficheros como: gzip, bzip, zip o rar.
Los formatos más utilizados en Unix son gzip y bzip.</p>
<p>Comprimir un fichero con gzip o bzip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ gzip informacion_snps.txt
$ ls
informacion_snps.txt.gz

$ bzip2 accs.txt
$ ls
accs.txt.bz2
</pre></div>
</div>
<p>bzip2 comprime más que gzip, pero es más lento.
gzip también dispone de varios niveles de compresión, cuanto más comprime más lenta suele ser la compresión.</p>
<p>Podemos descomprimir cualquier fichero utilizando la línea de comandos:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ gunzip informacion_snps.txt.gz
$ ls
informacion_snps.txt
$ bunzip2 accs.txt.bz2
$ ls
accs.txt
</pre></div>
</div>
<p>Muchos estamos acostumbrados al formato zip.
Un fichero zip no se corresponde en realidad con un sólo fichero comprimido sino con varios.
Un fichero zip hace dos cosas: unir varios ficheros en uno y comprimir el resultado.
Los comandos que hemos visto (gzip y bzip2) son capaces de comprimir un sólo archivo, pero no pueden unir varios archivos en uno.
<em>tar</em> es el comando capaz de unir varios archivos en uno.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ls
seq1.fasta  seq2.fasta
$ tar -cvf secuencias.tar seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar  seq1.fasta  seq2.fasta
</pre></div>
</div>
<p><em>tar</em> también es capaz de desempaquetar los archivos que habíamos unido.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ls
secuencias.tar
$ rm seq1.fasta seq2.fasta
$ tar -xvf secuencias.tar
seq1.fasta
seq2.fasta
$ ls
secuencias.tar  seq1.fasta  seq2.fasta
</pre></div>
</div>
<p>El problema es que utilizando el comando <em>tar</em> tal y como lo hemos hecho hemos conseguido unir y separar archivos, pero no hemos comprimido el fichero unido.
Para hacerlo podríamos utilizar los comandos <em>gzip</em> o <em>bzip2</em>, pero este no es el modo habitula de hacerlo.
Dado que casi siempre que unamos archivos en un archivo tar también querremos comprimir el resultado el comando tar tiene también la capacidad de comprimir y descomprimir utilizando los algoritmos gzip y bzip2.
Unir y comprimir con gzip varios archivos:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ tar -cvzf secuencias.tar.gz seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.gz  seq1.fasta  seq2.fasta
</pre></div>
</div>
<p>Descomprimir un archivo tar.gz:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ tar -xvzf secuencias.tar.gz
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.gz  seq1.fasta  seq2.fasta
</pre></div>
</div>
<p>También podemos descomprimir el contenido de un fichero de texto y enviar el resultado a la terminal con el comando <em>zcat</em>.</p>
<blockquote>
<div><p>$ zcat fichero.txt.gz</p>
</div></blockquote>
<p>Con bzip2.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ tar -cvjf secuencias.tar.bz seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.bz  seq1.fasta  seq2.fasta

$ tar -xvjf secuencias.tar.bz
seq1.fasta
seq2.fasta
</pre></div>
</div>
<section id="id2">
<h3>Ejercicios<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Crea un fichero de texto en el directorio ~/Documentos y comprimelo con gzip</p></li>
<li><p>Muestra el contenido del fichero anterior en pantalla sin descomprimirlo previamente</p></li>
<li><p>Crea un archivo tar de todo el contenido del directorio ~/Documentos</p></li>
<li><p>Comprime el fichero tar anterior</p></li>
<li><p>Vuelve a hacer los ejercicios 2 y 3, pero en un sólo paso</p></li>
<li><p>Descomprime el fichero tar.gz anterior en un nuevo directorio llamado Documentos2</p></li>
</ol>
</section>
</section>
<section id="enlaces-duros-y-blandos">
<h2>Enlaces duros y blandos<a class="headerlink" href="#enlaces-duros-y-blandos" title="Permalink to this heading">¶</a></h2>
<p>Podemos pensar en el nombre de un fichero como en una etiqueta que apunta a una posición concreta en el disco duro, en realidad es un puntero a un <a class="reference external" href="https://en.wikipedia.org/wiki/Inode">inodo</a>.</p>
<p>Podmeos pensar en un <a class="reference external" href="https://en.wikipedia.org/wiki/Hard_link">enlace duro</a> como en un nombre adicional para un archivo.
Si tenemos un archivo en el disco y creamos un enlace duro tendremos dos nombres para ese único archivo.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ls
archivo1.txt
$ ln archivo1.txt nombre2.txt
$ ls
archivo1.txt nombre2.txt
</pre></div>
</div>
<p>Las dos referencias, nombres, al archivo serán indistinguibles.
Si borramos un nombre quedará el otro.
Si modificamos un archivo se modifica independientemente del nombre por el cual estemos accediendo a él.
No es muy común utilizar enlaces duro salvo en aplicaciones muy concretas, por ejemplo en versiones de copias de seguridad.</p>
<p>Un enlace blando, más comumente conocido como un enlace simbólico, es una referencia al nombre de un archivo, no al archivo en sí.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ls
archivo1.txt
$ ln -s archivo1.txt nombre3.txt
$ ls -l
-rw-rw-r-- 1 jose jose  0 sep 27 15:16 archivo1.txt
lrwxrwxrwx 1 jose jose 12 sep 27 15:16 nombre3.txt -&gt; archivo1.txt
</pre></div>
</div>
<p>Si eliminamos el archivo original el enlace quedará roto.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ rm archivo1.txt
$ cat nombre3.txt
cat: nombre3.txt: No existe el archivo o el directorio
</pre></div>
</div>
<p>El comportamiento de ambos tipos de enlaces cambia si sobreescribimos el fichero.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x
$ echo &quot;hola&quot; &gt; hola.txt
$ cat hola.txt
hola
$ ln hola.txt hola2.txt
$ ln -s hola.txt hola3.txt
$ ls -l
-rw-rw-r-- 2 jose jose 5 sep 27 15:23 hola2.txt
lrwxrwxrwx 1 jose jose 8 sep 27 15:25 hola3.txt -&gt; hola.txt
-rw-rw-r-- 2 jose jose 5 sep 27 15:23 hola.txt
$ echo &quot;adios&quot; &gt; adios.txt
$ mv adios.txt hola.txt
$ cat hola.txt
adios
$ cat hola2.txt
hola
</pre></div>
</div>
<p>Los enlaces blandos funcionan incluso entre distintos sistemas de archivos o particiones, los duros no.</p>
</section>
<section id="id3">
<h2>Ejercicios<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>Crea un enlace simbólico a un fichero de texto dentro del direcotorio ~/Documentos</p></li>
<li><p>Crea un enlace duro al mismo fichero.</p></li>
<li><p>Edita el fichero de texto y observa como cambian ambos enlaces</p></li>
<li><p>Crea un nuevo fichero de texto con otro contenido. Sustituye el primer fichero con el segundo y observa el resultado en ambos enlaces</p></li>
<li><p>Crea dos enlaces, uno simbólico y otro duro, a un fichero. Elimina el fichero y observa el resultado en ambos enlaces</p></li>
</ol>
</section>
<section id="acceso-remoto">
<h2>Acceso remoto<a class="headerlink" href="#acceso-remoto" title="Permalink to this heading">¶</a></h2>
<p>Una de las grandes ventajas de utilizar la terminal es que podemos acceder a terminales en otros ordenadores muy fácilmente.
El protocolo más utilizado para acceder a terminales de forma remota es <a class="reference external" href="https://en.wikipedia.org/wiki/Secure_Shell">ssh</a> (Secure Shell).
ssh tiene un gran número de posibilidades, pero el uso más habitual es utilizarlo para abrir terminales en ordenadores remotos que tienen un servicio ssh.
ssh es seguro porque cifra las comunicaciones entre el cliente y el servidor.
ssh se diseñó como una alternativa segura a telnet.
No debemos usar el protocolo telnet porque las comunicaciones en telnet, incluidas las claves de acceso, no están cifradas y cualquiera puede tener acceso a ellas.</p>
<p>Para acceder a una computadora que implemente el protocolo ssh podemos usar el programa ssh, pero previamente tenemos que tener una cuenta en esa computadora.
Imaginemos que alicia tiene una cuenta en un ordenador que tiene un servicio ssh.
Para conectarse puede hacer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ssh alicia@ordenador.upv.es
</pre></div>
</div>
<p>Si el nombre de la cuenta de usuario en el ordenador cliente y en el servidor es el mismo puede obviar el nombre de usuario.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ssh ordenador.upv.es
</pre></div>
</div>
<p>A continuación el servidor le pedirá la clave correspondiente a ese usuario.</p>
<p>Existen clientes ssh para windows con los que nos podemos conectar a servidores ssh.
Uno muy común es <a class="reference external" href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">putty</a>.</p>
<p>Una tarea muy habitual cuando estamos trabajando en un ordenador remoto es enviar o traer ficheros desde el mismo.
Esto también lo podemos hacer utilizando el protocolo ssh por lo que podremos hacerlo de un modo seguro en cualquier ordenador que no de acceso ssh.
El programa más sencillo para hacerlo desde Unix es <a class="reference external" href="https://en.wikipedia.org/wiki/Secure_copy">*scp*</a> (Secure CoPy).
<em>scp</em> tiene una interfaz muy similar a <em>cp</em> pero acepta que los ficheros de origen y destino estén en distintos ordenadores:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ scp alicia@remotehost.edu:/remote/directory/seq.txt /some/local/directory
$ scp /some/local/directory/seq.txt alicia@remotehost.edu:/remote/directory/
</pre></div>
</div>
<p>En windows también hay distintos clientes scp, uno de ellos es <a class="reference external" href="https://winscp.net/eng/download.php">winscp</a>.</p>
<p>Una alternativa a scp que tiene más capacidades, como enviar fragmentos de ficheros, es <a class="reference external" href="https://en.wikipedia.org/wiki/Rsync">rsync</a>.
<em>rsync</em> está diseñado para mantener varios archivos sincronizados entre dos ordenadores, pero también ser puede utilizar para copiar archivos de un ordenador a otro como scp.
<em>rsync</em> puede establecer la conexión utilizando distintos protocolos, pero uno de ellos es ssh por lo que funcionará también con cualquier servidor ssh.</p>
<p>Si lo que queremos es descargar un fichero desde un servidor en internet, por ejemplo desde una página web, al ordenador remoto en el que estamos trabajando en una sesión ssh podemos utilizar el comando <em>wget</em> o su alternativa <em>curl</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ wget https://http://ncbi.nlm.nih.gov/una_secuencia.fasta
</pre></div>
</div>
<section id="id4">
<h3>Ejercicios<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Contectate a un servidor remoto usando ssh</p></li>
<li><p>Transfiere un fichero desde tu ordenador al servidor</p></li>
<li><p>Descarga el fichero <a class="reference external" href="https://www.gnu.org/licenses/gpl.txt">https://www.gnu.org/licenses/gpl.txt</a> directamente en el ordenador remoto</p></li>
<li><p>Copia el fichero gpl.txt a tu ordenador</p></li>
</ol>
</section>
</section>
</section>



        

    </main>

</div>
    <footer>
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/"><img alt="Licencia de Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" property="dct:title">Bioinformatics at COMAV</span> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Reconocimiento 4.0 Internacional License</a>.
    </footer>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-16108274-1");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>