[{"name": "app.py", "content": "import math\n\nfrom shiny import App, reactive, render, ui\nimport matplotlib.pyplot as plt\n\nfrom one_locus_two_alleles_simulator import (\n    OneLocusTwoAlleleSimulation,\n    INF,\n    MutRates,\n    Fitness,\n)\n\n# The UI section consists of a single (potentially very long and deeply nested) expression,\n# stored as a variable named app_ui by convention. The object this produces is actually simply HTML,\n# which is sent to the browser when it first loads the app.\n\n# Broadly speaking, there are two kinds of UI components in Shiny: container components, which,\n# as the name suggests, can contain other components, and non-container components, which cannot.\n# (You can also think of the UI as a tree data structure: container components have children,\n# while non-container components are leaf nodes in the tree.)\n# some examples of container components:\n#\n#    ui.sidebar()\n#    ui.card()\n#    ui.layout_columns()\n#    ui.div()\n# some examples of non-container components:\n#    ui.input_text()\n#    ui.output_plot()\n#\n# to put a component inside of a container, you nest the function calls, like ui.sidebar(ui.input_text())\n\nMIN_POP_SIZE = 10\nMAX_POP_SIZE = 1000\nDEF_POP_SIZE = 100\nDEF_GENO_FREQS = (0.25, 0.75)\nDEF_FREQ_Aa = DEF_GENO_FREQS[1] - DEF_GENO_FREQS[0]\nDEF_FREQ_A = DEF_GENO_FREQS[0] + DEF_FREQ_Aa * 0.5\nMIN_NUM_GEN = 10\nMAX_NUM_GEN = 500\nDEF_NUM_GEN = 100\n\nGENOMIC_FREQS_TAB_ID = \"genotypic_freqs\"\nALLELIC_FREQS_TAB_ID = \"allelic_freqs\"\nGENO_FREQS_PLOT_ID = \"geno_freqs_plot\"\nFREQ_A_PLOT_ID = \"freq_A_plot\"\nEXP_HET_PLOT_ID = \"exp_het_plot\"\n\n\nfreq_A_Aa_widget = ui.row(\n    ui.input_numeric(\n        \"freq_A_input\", \"Freq. A\", DEF_FREQ_A, min=0.0, max=1.0, step=0.01\n    ),\n    ui.input_numeric(\n        \"freq_Aa_input\", \"Freq. Aa\", DEF_FREQ_Aa, min=0.0, max=1.0, step=0.01\n    ),\n)\n\ngeno_freqs_slider = ui.row(\n    ui.input_slider(\n        \"geno_freqs_slider\",\n        label=\"\",\n        min=0,\n        max=1,\n        value=DEF_GENO_FREQS,\n        width=\"100%\",\n    ),\n)\n\npanels = [\n    ui.nav_panel(\"Genomic freqs.\", geno_freqs_slider, value=GENOMIC_FREQS_TAB_ID),\n    ui.nav_panel(\"Allelic freqs.\", freq_A_Aa_widget, value=ALLELIC_FREQS_TAB_ID),\n]\n\nfreqs_tab = ui.navset_card_tab(\n    *panels,\n    id=\"freqs_tabs\",\n)\n\npop_size_panel = (\n    ui.layout_columns(\n        ui.panel_conditional(\n            \"!input.pop_is_inf_checkbox\",\n            ui.input_slider(\n                \"pop_size_slider\",\n                label=\"\",\n                min=MIN_POP_SIZE,\n                max=MAX_POP_SIZE,\n                value=DEF_POP_SIZE,\n                width=\"100%\",\n            ),\n        ),\n        ui.input_checkbox(\"pop_is_inf_checkbox\", label=\"Pop. is inf.\", value=False),\n        col_widths=(10, 2),\n    ),\n)\n\nnum_gen_panel = (\n    ui.input_slider(\n        \"num_gen_slider\",\n        label=\"\",\n        min=MIN_NUM_GEN,\n        max=MAX_NUM_GEN,\n        value=DEF_NUM_GEN,\n        width=\"100%\",\n    ),\n)\n\n\nfitness_panel = (\n    ui.input_slider(\"wAA_slider\", label=\"wAA\", min=0, max=1, value=1),\n    ui.input_slider(\"wAa_slider\", label=\"wAa\", min=0, max=1, value=1),\n    ui.input_slider(\"waa_slider\", label=\"waa\", min=0, max=1, value=1),\n)\n\nmutation_panel = (\n    ui.input_slider(\"A2a_slider\", label=\"A2a\", min=0, max=0.1, value=0),\n    ui.input_slider(\"a2A_slider\", label=\"a2A\", min=0, max=0.1, value=0),\n)\nselfing_panel = (\n    ui.input_slider(\"selfing_slider\", label=\"Selfing rate\", min=0, max=1, value=0),\n)\n\ninputs_panel = ui.accordion(\n    ui.accordion_panel(\"Initial freqs.\", freqs_tab),\n    ui.accordion_panel(\"Pop. size\", pop_size_panel),\n    ui.accordion_panel(\"Num. generations\", num_gen_panel),\n    ui.accordion_panel(\"Selection\", fitness_panel),\n    ui.accordion_panel(\"Mutation\", mutation_panel),\n    ui.accordion_panel(\"Selfing\", selfing_panel),\n    id=\"inputs_panel\",\n    open=[\"Initial freqs.\", \"Pop. size\", \"Num. generations\"],\n)\n\nsim_params_widget = ui.layout_columns(\n    ui.value_box(\n        title=\"Freq. AA\",\n        value=ui.output_ui(\"freq_AA_output\"),\n    ),\n    ui.value_box(\n        title=\"Freq. Aa\",\n        value=ui.output_ui(\"freq_Aa_output\"),\n    ),\n    ui.value_box(\n        title=\"Freq. aa\",\n        value=ui.output_ui(\"freq_aa_output\"),\n    ),\n)\n\nrun_button = ui.input_action_button(\"run_button\", \"Run simulation\")\n\ninput_card = ui.card(\n    ui.h1(\"One locus foward in time simulation\"),\n    ui.card(inputs_panel, sim_params_widget),\n    run_button,\n)\n\noutput_panels = (\n    ui.nav_panel(\n        \"Genotypic freqs.\",\n        ui.output_plot(GENO_FREQS_PLOT_ID),\n    ),\n    ui.nav_panel(\n        \"Freq A.\",\n        ui.output_plot(FREQ_A_PLOT_ID),\n    ),\n    ui.nav_panel(\n        \"Exp. Het.\",\n        ui.output_plot(EXP_HET_PLOT_ID),\n    ),\n)\n\noutput_card = ui.card(\n    ui.navset_tab(\n        *output_panels,\n    )\n)\n\n\napp_ui = ui.page_fixed(\n    input_card,\n    output_card,\n)\n\n# The server section is a function, named server by convention,\n# that always takes the arguments input, output, and session.\n# This function contains render functions and reactive functions, which are used to update the UI in\n# response to user input.\n\n\ndef server(input, output, session):\n    def get_pop_size():\n        pop_size = int(input.pop_size_slider())\n        if input.pop_is_inf_checkbox():\n            pop_size = INF\n        return pop_size\n\n    @reactive.calc\n    def get_freq_AA():\n        if input.freqs_tabs() == GENOMIC_FREQS_TAB_ID:\n            freq_AA = input.geno_freqs_slider()[0]\n        elif input.freqs_tabs() == ALLELIC_FREQS_TAB_ID:\n            freq_Aa = input.freq_Aa_input()\n            freq_A = input.freq_A_input()\n            freq_AA = freq_A - (freq_Aa / 2)\n        return freq_AA\n\n    @reactive.calc\n    def get_freq_aa():\n        if input.freqs_tabs() == GENOMIC_FREQS_TAB_ID:\n            freq_aa = 1 - input.geno_freqs_slider()[1]\n        elif input.freqs_tabs() == ALLELIC_FREQS_TAB_ID:\n            freq_Aa = input.freq_Aa_input()\n            freq_A = input.freq_A_input()\n            freq_aa = (1 - freq_A) - (freq_Aa / 2)\n        return freq_aa\n\n    @reactive.calc\n    def get_freq_Aa():\n        if input.freqs_tabs() == GENOMIC_FREQS_TAB_ID:\n            freq_Aa = input.geno_freqs_slider()[1] - input.geno_freqs_slider()[0]\n        elif input.freqs_tabs() == ALLELIC_FREQS_TAB_ID:\n            freq_Aa = input.freq_Aa_input()\n        return freq_Aa\n\n    @reactive.calc\n    def get_num_generations():\n        return input.num_gen_slider()\n\n    @reactive.calc\n    def get_freq_A():\n        if input.freqs_tabs() == GENOMIC_FREQS_TAB_ID:\n            freq_A = get_freq_AA() + get_freq_Aa() * 0.5\n        elif input.freqs_tabs() == ALLELIC_FREQS_TAB_ID:\n            freq_A = input.freq_A_input()\n        return freq_A\n\n    @reactive.effect\n    @reactive.event(input.freq_Aa_input)\n    def _():\n        freq_Aa = input.freq_Aa_input()\n        min_ = round(freq_Aa, ndigits=2)\n        max_ = 1 - freq_Aa\n        current_value = input.freq_A_input()\n        if current_value < min_:\n            current_value = min_\n        elif current_value > max_:\n            current_value = max_\n        ui.update_numeric(\"freq_A_input\", min=min_, max=max_, value=current_value)\n\n    @reactive.effect\n    @reactive.event(input.freq_A_input)\n    def _():\n        freq_A = input.freq_A_input()\n        freq_a = 1 - freq_A\n        max_ = round(min((freq_A, freq_a)), ndigits=2)\n        current_value = input.freq_Aa_input()\n        if current_value > max_:\n            current_value = max_\n        ui.update_numeric(\"freq_Aa_input\", min=0, max=max_, value=current_value)\n\n    @render.text\n    def freq_AA_output():\n        return f\"{get_freq_AA():.2f}\"\n\n    @render.text\n    def freq_Aa_output():\n        return f\"{get_freq_Aa():.2f}\"\n\n    @render.text\n    def freq_aa_output():\n        return f\"{get_freq_aa():.2f}\"\n\n    @reactive.calc\n    @reactive.event(input.run_button)\n    def do_simulation():\n        sim_params = {\n            \"pops\": {\n                \"pop1\": {\n                    \"genotypic_freqs\": (get_freq_AA(), get_freq_Aa(), get_freq_aa()),\n                    \"size\": get_pop_size(),\n                    \"selfing_rate\": input.selfing_slider(),\n                },\n            },\n            \"num_generations\": get_num_generations(),\n            \"loggers\": [\n                \"allelic_freqs_logger\",\n                \"genotypic_freqs_logger\",\n                \"exp_het_logger\",\n            ],\n        }\n\n        wAA = input.wAA_slider()\n        wAa = input.wAa_slider()\n        waa = input.waa_slider()\n        if (\n            not math.isclose(wAA, 1)\n            or not math.isclose(wAa, 1)\n            or not math.isclose(waa, 1)\n        ):\n            sim_params[\"pops\"][\"pop1\"][\"fitness\"] = (wAA, wAa, waa)\n\n        A2a = input.A2a_slider()\n        a2A = input.a2A_slider()\n        if not math.isclose(A2a, 0) or not math.isclose(a2A, 0):\n            sim_params[\"pops\"][\"pop1\"][\"mut_rates\"] = MutRates(A2a, a2A)\n\n        sim = OneLocusTwoAlleleSimulation(sim_params)\n        return sim\n\n    @render.plot(alt=\"Genotypic freqs.\")\n    def geno_freqs_plot():\n        sim = do_simulation()\n\n        fig, axes = plt.subplots()\n        axes.set_title(\"Genotypic freqs.\")\n        axes.set_xlabel(\"generation\")\n        axes.set_ylabel(\"freq\")\n\n        genotypic_freqs = sim.results[\"genotypic_freqs\"]\n        geno_freqs_labels = sorted(genotypic_freqs.keys())\n        for geno_freq_label in geno_freqs_labels:\n            geno_freqs_series = genotypic_freqs[geno_freq_label]\n            axes.plot(\n                geno_freqs_series.index, geno_freqs_series.values, label=geno_freq_label\n            )\n        axes.legend()\n        axes.set_ylim((0, 1))\n        return fig\n\n    @render.plot(alt=\"Freq. A\")\n    def freq_A_plot():\n        sim = do_simulation()\n\n        fig, axes = plt.subplots()\n        axes.set_title(\"Freq. A\")\n        axes.set_xlabel(\"generation\")\n        axes.set_ylabel(\"freq\")\n\n        freqs_series = sim.results[\"allelic_freqs\"]\n        axes.plot(freqs_series.index, freqs_series.values, label=\"Freq. A\")\n        axes.set_ylim((0, 1))\n        return fig\n\n    @render.plot(alt=\"Exp. Het.\")\n    def exp_het_plot():\n        sim = do_simulation()\n\n        fig, axes = plt.subplots()\n        axes.set_title(\"Expected Het.\")\n        axes.set_xlabel(\"generation\")\n        axes.set_ylabel(\"Exp. Het.\")\n\n        freqs_series = sim.results[\"expected_hets\"]\n        axes.plot(freqs_series.index, freqs_series.values, label=\"Exp. Het.\")\n        axes.set_ylim((0, 1))\n        return fig\n\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "one_locus_two_alleles_simulator.py", "content": "from typing import Callable, Iterable\nimport random\nimport math\nfrom array import array\nfrom collections import defaultdict, namedtuple\n\nimport numpy\nimport pandas\n\nINF = math.inf\n\nMENDELIAN_SEGREGATIONS = {\n    (\"AA\", \"AA\"): [(1, 0, 0)],\n    (\"aa\", \"aa\"): [(0, 0, 1)],\n    (\"AA\", \"aa\"): [(0, 1, 0)],\n    (\"aa\", \"AA\"): [(0, 1, 0)],\n    (\"AA\", \"Aa\"): ((1, 0, 0), (0, 1, 0)),\n    (\"Aa\", \"AA\"): ((1, 0, 0), (0, 1, 0)),\n    (\"aa\", \"Aa\"): ((0, 0, 1), (0, 1, 0)),\n    (\"Aa\", \"aa\"): ((0, 0, 1), (0, 1, 0)),\n    (\"Aa\", \"Aa\"): (\n        (1, 0, 0),\n        (0, 1, 0),\n        (0, 1, 0),\n        (0, 0, 1),\n    ),\n}\n\n\nclass GenotypicFreqs:\n    def __init__(self, freq_AA: float, freq_Aa: float, freq_aa: float | None = None):\n        freq_AA = float(freq_AA)\n        freq_Aa = float(freq_Aa)\n\n        if freq_AA > 1:\n            raise ValueError(\"freq AA can not be larger than 1\")\n        if freq_AA < 0:\n            raise ValueError(\"freq AA can not be lower than 0\")\n        if freq_Aa < 0:\n            raise ValueError(\"freq Aa can not be lower than 0\")\n        if freq_AA + freq_Aa > 1:\n            raise ValueError(\"AA + Aa freqs cannot be greater than 1\")\n\n        self._AA = freq_AA\n        self._Aa = freq_Aa\n        expected_freq_aa = 1 - self._AA - self._Aa\n        if freq_aa is not None:\n            if freq_aa < 0:\n                raise ValueError(\"freq A0 can not be lower than 0\")\n            if not math.isclose(expected_freq_aa, freq_aa, abs_tol=0.01):\n                raise ValueError(\n                    f\"freq_aa ({freq_aa}) should be 1 - freq_AA - freq_Aa ({expected_freq_aa})\"\n                )\n        freq_aa = expected_freq_aa\n\n        if not math.isclose(freq_aa + freq_AA + freq_Aa, 1):\n            raise ValueError(\"Genotypic freqs should sum 1\")\n        self._aa = freq_aa\n\n    @property\n    def freqs(self):\n        return (self.AA, self.Aa, self.aa)\n\n    @property\n    def A(self):\n        return self._AA + self._Aa * 0.5\n\n    @property\n    def AA(self):\n        return self._AA\n\n    @property\n    def Aa(self):\n        return self._Aa\n\n    @property\n    def aa(self):\n        return self._aa\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self.AA}, {self.Aa}, {self.aa})\"\n\n\nclass AllelicFreqs:\n    def __init__(self, freq_A):\n        self.A = freq_A\n        freq_a = 1 - freq_A\n        self.a = freq_a\n        if not math.isclose(freq_A + freq_a, 1):\n            raise ValueError(\"Allelic freqs should sum 1\")\n\n    def __str__(self):\n        return f\"A: {self.A}, a: {self.a}\"\n\n\nclass Fitness:\n    def __init__(self, w11, w12, w22):\n        if numpy.allclose([w11, w12, w22], [0, 0, 0]):\n            raise ValueError(\"Some of the fitness values should be non zero\")\n        self.w11 = w11\n        self.w12 = w12\n        self.w22 = w22\n\n\nMutRates = namedtuple(\"MutRates\", (\"A2a\", \"a2A\"))\n\n\ndef calc_allelic_freq(genotypic_freqs: GenotypicFreqs):\n    return genotypic_freqs.AA + genotypic_freqs.Aa * 0.5\n\n\ndef calc_allelic_freqs(genotypic_freqs: GenotypicFreqs):\n    return AllelicFreqs(calc_allelic_freq(genotypic_freqs))\n\n\ndef calc_hwe_genotypic_freqs(allelic_freqs: AllelicFreqs):\n    freq_AA = allelic_freqs.A**2\n    freq_Aa = 2 * allelic_freqs.A * allelic_freqs.a\n    return GenotypicFreqs(freq_AA, freq_Aa)\n\n\nclass Population:\n    def __init__(\n        self,\n        id: str,\n        genotypic_freqs: GenotypicFreqs,\n        size: int | float = INF,\n        fitness: Fitness | None = None,\n        mut_rates: MutRates | None = None,\n        selfing_rate: float = 0.0,\n    ):\n        self.id = id\n        self.size = size\n        self.genotypic_freqs = genotypic_freqs\n        self.selfing_rate = selfing_rate\n\n        self.fitness = fitness\n\n        self.mut_rates = mut_rates\n\n    @property\n    def allelic_freqs(self):\n        genotypic_freqs = self.genotypic_freqs\n        return AllelicFreqs(calc_allelic_freq(genotypic_freqs))\n\n    def _choose_parent(self, freq_AA, freq_Aa):\n        value = random.uniform(0, 1)\n        if value < freq_AA:\n            return \"AA\"\n        elif value >= (freq_AA + freq_Aa):\n            return \"aa\"\n        else:\n            return \"Aa\"\n\n    def evolve_to_next_generation(self, migration_origins=None):\n        genotypic_freqs = self.genotypic_freqs\n\n        if migration_origins is None:\n            migration_origins = []\n\n        freq_AA = genotypic_freqs.AA\n        freq_Aa = genotypic_freqs.Aa\n\n        # migration\n        this_pop_contribution = 1 - sum(\n            [origin[\"inmigrant_rate\"] for origin in migration_origins]\n        )\n        if this_pop_contribution < 0:\n            raise ValueError(f\"Too many inmigrants for pop {self.id}, more than 100%\")\n\n        freq_AA = this_pop_contribution * freq_AA + sum(\n            [\n                origin[\"from_pop\"].genotypic_freqs.AA * origin[\"inmigrant_rate\"]\n                for origin in migration_origins\n            ]\n        )\n        freq_Aa = this_pop_contribution * freq_Aa + sum(\n            [\n                origin[\"from_pop\"].genotypic_freqs.Aa * origin[\"inmigrant_rate\"]\n                for origin in migration_origins\n            ]\n        )\n        freq_aa = this_pop_contribution * genotypic_freqs.aa + sum(\n            [\n                origin[\"from_pop\"].genotypic_freqs.aa * origin[\"inmigrant_rate\"]\n                for origin in migration_origins\n            ]\n        )\n        assert math.isclose(freq_AA + freq_Aa + freq_aa, 1)\n\n        # selection\n        fitness = self.fitness\n        if fitness is not None:\n            freq_AA = freq_AA * fitness.w11\n            freq_Aa = freq_Aa * fitness.w12\n            freq_aa = freq_aa * fitness.w22\n            sum_freqs = freq_AA + freq_Aa + freq_aa\n            freq_AA = freq_AA / sum_freqs\n            freq_Aa = freq_Aa / sum_freqs\n            freq_aa = freq_aa / sum_freqs\n            assert math.isclose(freq_AA + freq_Aa + freq_aa, 1)\n\n        # mutation\n        if self.mut_rates:\n            mu = self.mut_rates.A2a\n            mu2 = mu**2\n            nu = self.mut_rates.a2A\n            nu2 = nu**2\n            AA0 = freq_AA\n            Aa0 = freq_Aa\n            aa0 = 1 - freq_AA - freq_Aa\n\n            new_aa = AA0 * mu2 + Aa0 * mu\n            new_AA = aa0 * nu2 + Aa0 * nu\n            new_Aa = 2 * AA0 * mu + 2 * aa0 * nu\n            AA_removed = AA0 * mu2 + 2 * AA0 * mu\n            aa_removed = aa0 * nu2 + 2 * aa0 * nu\n            Aa_removed = Aa0 * mu + Aa0 * nu\n\n            AA1 = AA0 + new_AA - AA_removed\n            Aa1 = Aa0 + new_Aa - Aa_removed\n            aa1 = aa0 + new_aa - aa_removed\n            assert math.isclose(AA1 + Aa1 + aa1, 1)\n            freq_AA = AA1\n            freq_Aa = Aa1\n\n        # drift\n        selfing_rate = self.selfing_rate\n        if self.size is None or math.isinf(self.size):\n            # selfed indivuals\n            selfed_freq_AA1 = freq_AA + freq_Aa * 0.25\n            selfed_freq_Aa1 = freq_Aa * 0.5\n            # non selfed individuals\n            allelic_freqs = calc_allelic_freqs(GenotypicFreqs(freq_AA, freq_Aa))\n            panmix_genotypic_freqs = calc_hwe_genotypic_freqs(allelic_freqs)\n            # final freqs\n            freq_AA = selfed_freq_AA1 * selfing_rate + panmix_genotypic_freqs.AA * (\n                1 - selfing_rate\n            )\n            freq_Aa = selfed_freq_Aa1 * selfing_rate + panmix_genotypic_freqs.Aa * (\n                1 - selfing_rate\n            )\n        else:\n            num_AA = 0\n            num_Aa = 0\n            num_aa = 0\n            for _ in range(self.size):\n                parent1 = self._choose_parent(freq_AA, freq_Aa)\n\n                parent2 = None\n                if selfing_rate is not None:\n                    value = random.uniform(0, 1)\n                    if value < selfing_rate:\n                        parent2 = parent1\n                if parent2 is None:\n                    parent2 = self._choose_parent(freq_AA, freq_Aa)\n\n                mendelian_choices = MENDELIAN_SEGREGATIONS[(parent1, parent2)]\n                if len(mendelian_choices) == 1:\n                    descendants = mendelian_choices[0]\n                else:\n                    descendants = random.choice(mendelian_choices)\n                num_AA += descendants[0]\n                num_Aa += descendants[1]\n                num_aa += descendants[2]\n\n            total_indis = num_AA + num_Aa + num_aa\n            assert total_indis == self.size\n\n            freq_AA = num_AA / total_indis\n            freq_Aa = num_Aa / total_indis\n\n        self.genotypic_freqs = GenotypicFreqs(freq_AA, freq_Aa)\n\n\ndef _update_events(demographic_events, num_generation, active_migrations):\n    for event in demographic_events:\n        event_num_generation = event.get(\"num_generation\")\n        if event_num_generation is not None and event_num_generation != num_generation:\n            continue\n\n        if event[\"type\"] == \"size_change\":\n            event[\"pop\"].size = event[\"new_size\"]\n        elif event[\"type\"] == \"migration_start\":\n            active_migrations[event[\"id\"]] = event\n        elif event[\"type\"] == \"migration_stop\":\n            del active_migrations[event[\"migration_id\"]]\n\n\ndef simulate_forward_in_time(\n    pops: list[Population],\n    num_generations: int,\n    loggers: list[Callable],\n    demographic_events: list[dict] | None = None,\n    random_seed: int | None = None,\n):\n    if random_seed is not None:\n        numpy.random.seed(random_seed)\n        random.seed(random_seed)\n\n    for logger in loggers:\n        logger(pops, num_generation=1)\n\n    if demographic_events is None:\n        demographic_events = []\n    active_migrations = {}\n    _update_events(demographic_events, 1, active_migrations)\n\n    for num_generation in range(2, num_generations + 1):\n        _update_events(demographic_events, num_generation, active_migrations)\n\n        for pop in pops:\n            migration_origin_pops = defaultdict(list)\n            for migration in active_migrations.values():\n                if migration[\"to_pop\"].id == pop.id:\n                    migration_origin_pops[pop.id].append(\n                        {\n                            \"from_pop\": migration[\"from_pop\"],\n                            \"inmigrant_rate\": migration[\"inmigrant_rate\"],\n                        }\n                    )\n            pop.evolve_to_next_generation(migration_origin_pops[pop.id])\n\n        for logger in loggers:\n            logger(pops, num_generation)\n\n\nclass _PerPopLogger:\n    def __init__(self):\n        self._values_per_generation = None\n        self._generations = array(\"L\")\n\n    @classmethod\n    def from_loggers(cls, loggers):\n        logger = cls()\n        logger._values_per_generation = pandas.concat(\n            [logger.values_per_generation for logger in loggers], axis=1\n        )\n        logger._generations = logger._values_per_generation.index\n        return logger\n\n    def __call__(self, pops: Iterable[Population], num_generation: int):\n        self._generations.append(num_generation)\n\n        if self._values_per_generation is None:\n            values = {pop.id: array(\"f\") for pop in pops}\n            self._values_per_generation = values\n        else:\n            values = self._values_per_generation\n\n        for pop in pops:\n            values[pop.id].append(self._calc_value_for_pop(pop))\n\n    @property\n    def values_per_generation(self):\n        values = self._values_per_generation\n        values = pandas.DataFrame(values, index=self._generations)\n        return values\n\n\nclass AllelicFreqLogger(_PerPopLogger):\n    def _calc_value_for_pop(self, pop):\n        return calc_allelic_freq(pop.genotypic_freqs)\n\n\nclass PopSizeLogger(_PerPopLogger):\n    def _calc_value_for_pop(self, pop):\n        size = pop.size\n        if size is None:\n            size = math.inf\n        return size\n\n\nclass ExpHetLogger(_PerPopLogger):\n    def _calc_value_for_pop(self, pop):\n        freq_A = calc_allelic_freq(pop.genotypic_freqs)\n        exp_het = 2 * freq_A * (1 - freq_A)\n        return exp_het\n\n\nGENOTYPIC_FREQS_NAMES = [\"freqs_AA\", \"freqs_Aa\", \"freqs_aa\"]\n\n\nclass GenotypicFreqsLogger:\n    def __init__(self):\n        self._values_per_generation = None\n        self._generations = array(\"L\")\n\n    @classmethod\n    def from_loggers(cls, loggers):\n        logger = cls()\n        values = {}\n        for genotypic_freq_name in loggers[0].values_per_generation.keys():\n            values[genotypic_freq_name] = pandas.concat(\n                [\n                    logger.values_per_generation[genotypic_freq_name]\n                    for logger in loggers\n                ],\n                axis=1,\n            )\n\n        logger._values_per_generation = values\n        logger._generations = values[genotypic_freq_name].index\n        return logger\n\n    def __call__(self, pops: Iterable[Population], num_generation: int):\n        self._generations.append(num_generation)\n\n        if self._values_per_generation is None:\n            values = {}\n            for genotypic_freq_name in GENOTYPIC_FREQS_NAMES:\n                values[genotypic_freq_name] = {}\n                for pop in pops:\n                    values[genotypic_freq_name][pop.id] = array(\"f\")\n            self._values_per_generation = values\n        else:\n            values = self._values_per_generation\n\n        for pop in pops:\n            for genotypic_freq_name, value in zip(\n                GENOTYPIC_FREQS_NAMES, pop.genotypic_freqs.freqs\n            ):\n                values[genotypic_freq_name][pop.id].append(value)\n\n    @property\n    def values_per_generation(self):\n        values = self._values_per_generation\n        dframes = {}\n        for genotypic_freq_name, freqs in values.items():\n            dframes[genotypic_freq_name] = pandas.DataFrame(\n                freqs, index=self._generations\n            )\n        return dframes\n\n\nLOGGER_CLASSES = {\n    \"allelic_freqs_logger\": AllelicFreqLogger,\n    \"pop_size_logger\": PopSizeLogger,\n    \"genotypic_freqs_logger\": GenotypicFreqsLogger,\n    \"exp_het_logger\": ExpHetLogger,\n}\nLOGGER_PARAMETERS = {\n    AllelicFreqLogger: \"allelic_freqs\",\n    PopSizeLogger: \"pop_sizes\",\n    GenotypicFreqsLogger: \"genotypic_freqs\",\n    ExpHetLogger: \"expected_hets\",\n}\n\n\nclass OneLocusTwoAlleleSimulation:\n    def __init__(self, sim_definition: dict):\n        pops = self._create_pops(sim_definition[\"pops\"])\n        events = self._create_demographic_events(\n            sim_definition.get(\"demographic_events\", {}), pops\n        )\n        loggers = self._create_loggers(sim_definition[\"loggers\"])\n        simulate_forward_in_time(\n            list(pops.values()),\n            num_generations=sim_definition[\"num_generations\"],\n            demographic_events=events,\n            loggers=loggers,\n        )\n        self.results = self._gather_results(loggers)\n\n    @staticmethod\n    def _create_pops(pop_definitions):\n        pops = {}\n        for pop_id in sorted(pop_definitions.keys()):\n            pop_def = pop_definitions[pop_id]\n            kwargs = {}\n            kwargs[\"genotypic_freqs\"] = GenotypicFreqs(*pop_def[\"genotypic_freqs\"])\n            if \"size\" in pop_def:\n                kwargs[\"size\"] = pop_def[\"size\"]\n            if \"fitness\" in pop_def:\n                kwargs[\"fitness\"] = Fitness(*pop_def[\"fitness\"])\n            if \"mut_rates\" in pop_def:\n                kwargs[\"mut_rates\"] = MutRates(*pop_def[\"mut_rates\"])\n            kwargs[\"selfing_rate\"] = float(pop_def.get(\"selfing_rate\", 0.0))\n\n            pops[pop_id] = Population(pop_id, **kwargs)\n        return pops\n\n    @staticmethod\n    def _create_demographic_events(demographic_events, pops):\n        events = []\n        for event_id, event in demographic_events.items():\n            event[\"id\"] = event_id\n            for key in [\"pop\", \"from_pop\", \"to_pop\"]:\n                if key in event:\n                    event[key] = pops[event[key]]\n            events.append(event)\n        return events\n\n    @staticmethod\n    def _create_loggers(loggers):\n        logger_objs = []\n        for logger in loggers:\n            logger_objs.append(LOGGER_CLASSES[logger]())\n        return logger_objs\n\n    @staticmethod\n    def _gather_results(loggers):\n        results = {}\n        for logger in loggers:\n            param = LOGGER_PARAMETERS[logger.__class__]\n            values = logger.values_per_generation\n            results[param] = values\n        return results\n\n\ndef simulate(\n    pops: list[Population],\n    num_generations: int,\n    loggers: list[Callable],\n    demographic_events: list[dict] | None = None,\n    random_seed: int | None = None,\n):\n    if random_seed is not None:\n        numpy.random.seed(random_seed)\n        random.seed(random_seed)\n\n    for logger in loggers:\n        logger(pops, num_generation=1)\n\n    if demographic_events is None:\n        demographic_events = []\n    active_migrations = {}\n    _update_events(demographic_events, 1, active_migrations)\n\n    for num_generation in range(2, num_generations + 1):\n        _update_events(demographic_events, num_generation, active_migrations)\n\n        for pop in pops:\n            migration_origin_pops = defaultdict(list)\n            for migration in active_migrations.values():\n                if migration[\"to_pop\"].id == pop.id:\n                    migration_origin_pops[pop.id].append(\n                        {\n                            \"from_pop\": migration[\"from_pop\"],\n                            \"inmigrant_rate\": migration[\"inmigrant_rate\"],\n                        }\n                    )\n            pop.evolve_to_next_generation(migration_origin_pops[pop.id])\n\n        for logger in loggers:\n            logger(pops, num_generation)\n\n\ndef simulate_one_locus_two_alleles_one_pop(\n    freq_AA,\n    freq_Aa,\n    freq_aa,\n    pop_size=INF,\n    num_generations=100,\n    w11=1,\n    w12=1,\n    w22=1,\n    A2a=0,\n    a2A=0,\n    selfing_rate=0,\n    num_populations=1,\n):\n\n    if (w11, w12, w22) == (1, 1, 1):\n        fitness = None\n    else:\n        fitness = Fitness(w11=w11, w12=w12, w22=w22)\n\n    if A2a == 0 and a2A == 0:\n        mut_rates = None\n    else:\n        mut_rates = MutRates(A2a, a2A)\n\n    loggers = {\n        \"genotypic_freqs_logger\": [],\n        \"allelic_freqs_logger\": [],\n        \"exp_het_logger\": [],\n    }\n    for idx in range(num_populations):\n        genotypic_freqs = GenotypicFreqs(\n            freq_AA=freq_AA, freq_Aa=freq_Aa, freq_aa=freq_aa\n        )\n        pop = Population(\n            id=f\"pop{idx}\",\n            size=pop_size,\n            genotypic_freqs=genotypic_freqs,\n            fitness=fitness,\n            mut_rates=mut_rates,\n            selfing_rate=selfing_rate,\n        )\n\n        allelic_freqs_logger = AllelicFreqLogger()\n        genotypic_freqs_logger = GenotypicFreqsLogger()\n        exp_het_logger = ExpHetLogger()\n        simulate(\n            pops=[pop],\n            num_generations=num_generations,\n            demographic_events=None,\n            random_seed=None,\n            loggers=[allelic_freqs_logger, genotypic_freqs_logger, exp_het_logger],\n        )\n        loggers[\"genotypic_freqs_logger\"].append(genotypic_freqs_logger)\n        loggers[\"allelic_freqs_logger\"].append(allelic_freqs_logger)\n        loggers[\"exp_het_logger\"].append(exp_het_logger)\n\n    loggers = {\n        key: logger_list[0].__class__.from_loggers(logger_list)\n        for key, logger_list in loggers.items()\n    }\n\n    return loggers\n", "type": "text"}, {"name": "requirements.txt", "content": "matplotlib", "type": "text"}]