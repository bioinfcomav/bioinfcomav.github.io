[{"name": "app.py", "content": "import math\nfrom urllib.parse import unquote, urlencode\nimport json\n\nfrom shiny import App, reactive, render, ui, module\nimport pandas\nimport matplotlib.pyplot as plt\nfrom matplotlib.lines import Line2D\n\nfrom one_locus_two_alleles_simulator import OneLocusTwoAlleleSimulation, INF\nimport config as config_module\nimport style\n\nAPP_ID = \"one_locus_app\"\nMAX_MUTATION_RATE = 0.1\n\n\ndef create_num_gen_panel(config):\n    slider = ui.input_slider(\n        id=\"num_gen_slider\",\n        label=\"\",\n        min=config[\"num_generations\"][\"min\"],\n        max=config[\"num_generations\"][\"max\"],\n        value=config[\"num_generations\"][\"value\"],\n        width=\"100%\",\n    )\n    panel = ui.accordion_panel(\"Num. generations\", slider)\n    return panel\n\n\ndef create_allelic_freqs_panel():\n    plot = ui.output_plot(\"allelic_freqs_plot\")\n    plot_panel = ui.nav_panel(\"Plot\", plot)\n    df = (ui.output_data_frame(\"allelic_freqs_df\"),)\n    table_panel = ui.nav_panel(\"Table\", df)\n\n    navset = ui.navset_tab(plot_panel, table_panel, id=\"allelic_freqs_navset\")\n\n    panel = ui.nav_panel(\"Allelic Freqs.\", navset)\n    return panel\n\n\ndef create_exp_het_panel():\n    plot = ui.output_plot(\"exp_het_plot\")\n    plot_panel = ui.nav_panel(\"Plot\", plot)\n    df = (ui.output_data_frame(\"expected_hets_df\"),)\n    table_panel = ui.nav_panel(\"Table\", df)\n\n    navset = ui.navset_tab(plot_panel, table_panel, id=\"exp_hets_navset\")\n\n    panel = ui.nav_panel(\"Expected het.\", navset)\n    return panel\n\n\ndef create_geno_freqs_plot_id(pop_name):\n    return f\"genotypic_freqs_plot_{pop_name}\"\n\n\n@module.ui\ndef genotypic_plot_ui():\n    return ui.output_plot(\"genotypic_plot\")\n\n\n@module.server\ndef genotypic_plot_server(input, output, session, geno_freqs: dict):\n    @render.plot\n    def genotypic_plot():\n        fig, axes = plt.subplots()\n        axes.set_title(\"Genotypic freqs.\")\n        axes.set_xlabel(\"generation\")\n        axes.set_ylabel(\"freq\")\n\n        colors = {}\n        for geno_freq_label, geno_freqs_seriess in geno_freqs.items():\n            color = colors.setdefault(geno_freq_label, next(style.COLOR_CYCLE))\n            for geno_freqs_series in geno_freqs_seriess:\n                axes.plot(\n                    geno_freqs_series.index,\n                    geno_freqs_series.values,\n                    label=geno_freq_label,\n                    color=color,\n                )\n        legend_lines = [\n            Line2D([0], [0], color=colors[freq_label], lw=2)\n            for freq_label in sorted(colors.keys())\n        ]\n        axes.legend(legend_lines, sorted(colors.keys()))\n        axes.set_ylim((0, 1))\n        return fig\n\n\ndef create_geno_freqs_module_plot_id(pop_name):\n    return f\"geno_freqs_plot_{pop_name}\"\n\n\ndef create_genotypic_freqs_panel(config):\n    panel_content = ui.output_ui(\"genotypic_plots\")\n    return ui.nav_panel(\"Genotypic Freqs.\", panel_content)\n\n\ndef create_simulation_output_card(config):\n    loggers = config[\"loggers\"]\n    panels = []\n    if \"allelic_freqs_logger\" in loggers:\n        panels.append(create_allelic_freqs_panel())\n    if \"genotypic_freqs_logger\" in loggers:\n        panels.append(create_genotypic_freqs_panel(config))\n    if \"exp_het_logger\" in loggers:\n        panels.append(create_exp_het_panel())\n\n    navset_tab = ui.navset_tab(*panels, id=\"output_navset\")\n    card = ui.card(navset_tab)\n    return card\n\n\ndef create_freqs_panel(pop_config):\n    if \"genotypic_freqs\" in pop_config:\n        geno_freqs = pop_config[\"genotypic_freqs\"]\n        freq_AA, freq_Aa, freq_aa = geno_freqs\n        freq_A = freq_AA + freq_Aa * 0.5\n    elif \"freq_A\" in pop_config:\n        freq_A = pop_config[\"freq_A\"]\n        freq_AA = freq_A**2\n        freq_a = 1 - freq_A\n        freq_aa = freq_a**2\n        freq_Aa = 1 - freq_AA - freq_aa\n        geno_freqs = (freq_AA, freq_Aa, freq_aa)\n    else:\n        raise ValueError(\n            \"Either genotypic_freqs or freq_A should be defined in the pop config\"\n        )\n\n    ui_options = pop_config[\"ui_freq_options\"]\n\n    freq_a_slider = ui.input_slider(\n        id=\"freq_a_slider\",\n        label=\"Freq. A\",\n        min=0,\n        max=1,\n        value=freq_A,\n        width=\"100%\",\n    )\n\n    geno_freqs_slider = ui.input_slider(\n        id=\"geno_freqs_slider\",\n        label=\"Geno. freqs. (AA, Aa, aa)\",\n        min=0,\n        max=1,\n        value=[freq_AA, freq_AA + freq_Aa],\n        width=\"100%\",\n    )\n\n    if \"genotypic\" in ui_options and \"allelic\" in ui_options:\n        allelic_panel = ui.nav_panel(\"With HW\", freq_a_slider)\n        genotypic_panel = ui.nav_panel(\"No HW\", geno_freqs_slider)\n        freqs_ui = ui.navset_tab(\n            allelic_panel,\n            genotypic_panel,\n            id=\"freqs_tabs\",\n        )\n    elif \"genotypic\" in ui_options:\n        freqs_ui = geno_freqs_slider\n    elif \"allelic\" in ui_options:\n        freqs_ui = freq_a_slider\n    else:\n        raise ValueError(\n            f\"Either genotypic, allelic or both should be in the pop {pop_config['name']} ui_options\"\n        )\n    genotypic_freqs = ui.layout_columns(\n        ui.value_box(\n            title=\"Freq. AA\",\n            value=ui.output_ui(\"freq_AA_output\"),\n            id=\"freq_AA_value_box\",\n        ),\n        ui.value_box(\n            \"Freq. Aa\",\n            ui.output_ui(\"freq_Aa_output\"),\n            id=\"freq_Aa_value_box\",\n        ),\n        ui.value_box(\n            \"Freq. aa\",\n            ui.output_ui(\"freq_aa_output\"),\n            id=\"freq_aa_value_box\",\n            class_=pop_config[\"name\"],\n        ),\n    )\n\n    panel = ui.accordion_panel(\"Initial freqs.\", freqs_ui, genotypic_freqs)\n    return panel\n\n\ndef create_pop_size_panel(pop_config):\n    size_slider = ui.input_slider(\n        id=\"size_slider\",\n        label=\"\",\n        min=pop_config[\"size\"][\"min\"],\n        max=pop_config[\"size\"][\"max\"],\n        value=pop_config[\"size\"][\"value\"],\n        width=\"100%\",\n    )\n\n    check_value = math.isinf(pop_config[\"size\"][\"value\"])\n    inf_size_checkbox = (\n        ui.input_checkbox(\"inf_size_checkbox\", \"Inf. size\", check_value),\n    )\n    conditional_panel = (\n        ui.panel_conditional(\n            \"!input.inf_size_checkbox\",\n            size_slider,\n        ),\n    )\n    panel = ui.accordion_panel(\"Size\", inf_size_checkbox, conditional_panel)\n    return panel\n\n\ndef create_selection_panel(pop_config):\n    fitness = pop_config[\"fitness\"]\n    wAA_slider = ui.input_slider(\n        id=\"wAA_slider\",\n        label=\"wAA\",\n        min=0,\n        max=1,\n        value=fitness[0],\n        width=\"100%\",\n    )\n    wAa_slider = ui.input_slider(\n        id=\"wAa_slider\",\n        label=\"wAa\",\n        min=0,\n        max=1,\n        value=fitness[1],\n        width=\"100%\",\n    )\n    waa_slider = ui.input_slider(\n        id=\"waa_slider\",\n        label=\"waa\",\n        min=0,\n        max=1,\n        value=fitness[2],\n        width=\"100%\",\n    )\n    panel = ui.accordion_panel(\n        \"Selection (Fitness)\", wAA_slider, wAa_slider, waa_slider\n    )\n    return panel\n\n\ndef create_mutation_panel(pop_config):\n    mutation = pop_config[\"mutation\"]\n    A2a_slider = ui.input_slider(\n        id=\"A2a_slider\",\n        label=\"A to a rate\",\n        min=0,\n        max=MAX_MUTATION_RATE,\n        value=mutation[\"A2a\"],\n        width=\"100%\",\n    )\n    a2A_slider = ui.input_slider(\n        id=\"a2A_slider\",\n        label=\"a to A rate\",\n        min=0,\n        max=MAX_MUTATION_RATE,\n        value=mutation[\"a2A\"],\n        width=\"100%\",\n    )\n    panel = ui.accordion_panel(\"Mutation\", A2a_slider, a2A_slider)\n    return panel\n\n\ndef create_selfing_rate_panel(pop_config):\n    slider = ui.input_slider(\n        id=\"selfing_slider\",\n        label=\"\",\n        min=0,\n        max=1,\n        value=pop_config[\"selfing_rate\"],\n        width=\"100%\",\n    )\n    panel = ui.accordion_panel(\"Selfing rate\", slider)\n    return panel\n\n\ndef create_immigration_slider_id(from_pop, to_pop):\n    return f\"immigration_slider_from_{from_pop}_to_{to_pop}\"\n\n\ndef create_immigration_panel(pop_config):\n    config = pop_config[\"immigration\"]\n    slider_id = create_immigration_slider_id(config[\"from_pop\"], pop_config[\"name\"])\n    slider = ui.input_slider(\n        id=slider_id,\n        label=\"\",\n        min=config[\"rate\"][\"min\"],\n        max=config[\"rate\"][\"max\"],\n        value=config[\"rate\"][\"value\"],\n        width=\"100%\",\n    )\n    panel = ui.accordion_panel(f\"Immigration from {config['from_pop']}\", slider)\n    return panel\n\n\n@module.ui\ndef create_pop_accordion(pop_config):\n    freqs_panel = create_freqs_panel(pop_config)\n    size_panel = create_pop_size_panel(pop_config)\n    panels = [freqs_panel, size_panel]\n    if \"fitness\" in pop_config:\n        selection_panel = create_selection_panel(pop_config)\n        panels.append(selection_panel)\n    if \"mutation\" in pop_config:\n        mutation_panel = create_mutation_panel(pop_config)\n        panels.append(mutation_panel)\n    if \"selfing_rate\" in pop_config:\n        selfing_rate_panel = create_selfing_rate_panel(pop_config)\n        panels.append(selfing_rate_panel)\n    if \"immigration\" in pop_config:\n        immigration_panel = create_immigration_panel(pop_config)\n        panels.append(immigration_panel)\n\n    pop_accordion = ui.accordion(\n        *panels,\n        id=\"pop_accordion\",\n        title=\"hola\",\n    )\n    return pop_accordion\n\n\nsim_config = reactive.value(None)\n\n\n@module.server\ndef pop_input_server(input, output, session, pop_name, config):\n    @reactive.calc\n    def calc_geno_allelic_freqs():\n        if \"freqs_tabs\" in input:\n            selected_tab = input.freqs_tabs.get()\n            use_geno_freqs_slider = selected_tab != \"With HW\"\n        else:\n            use_geno_freqs_slider = \"geno_freqs_slider\" in input\n\n        if use_geno_freqs_slider:\n            freq_AA, freq_AA_Aa = input.geno_freqs_slider()\n            freq_Aa = freq_AA_Aa - freq_AA\n            freq_aa = 1 - freq_AA_Aa\n            freq_A = freq_AA + freq_Aa * 0.5\n        else:\n            freq_A = input.freq_a_slider()\n            freq_a = 1 - freq_A\n            freq_AA = freq_A**2\n            freq_aa = freq_a**2\n            freq_Aa = 1 - freq_AA - freq_aa\n\n        return freq_AA, freq_Aa, freq_aa, freq_A\n\n    @render.text\n    def freq_AA_output():\n        freq = calc_geno_allelic_freqs()[0]\n        return f\"{freq:.2f}\"\n\n    @render.text\n    def freq_Aa_output():\n        freq = calc_geno_allelic_freqs()[1]\n        return f\"{freq:.2f}\"\n\n    @render.text\n    def freq_aa_output():\n        freq = calc_geno_allelic_freqs()[2]\n        return f\"{freq:.2f}\"\n\n    def get_size():\n        if input.inf_size_checkbox():\n            size = INF\n        else:\n            size = input.size_slider()\n        return size\n\n    def calc_pop_values():\n        freq_AA, freq_Aa, freq_aa, freq_A = calc_geno_allelic_freqs()\n        values = {\"genotypic_freqs\": (freq_AA, freq_Aa, freq_aa)}\n        values[\"size\"] = get_size()\n        if \"wAA_slider\" in input:\n            values[\"fitness\"] = (\n                input.wAA_slider(),\n                input.wAa_slider(),\n                input.waa_slider(),\n            )\n        if \"A2a_slider\" in input:\n            values[\"mut_rates\"] = (input.A2a_slider(), input.a2A_slider())\n        if \"selfing_slider\" in input:\n            values[\"selfing_rate\"] = input.selfing_slider()\n\n        demographic_events = {}\n        for pop_config in config[\"pops\"].values():\n            this_pop_name = pop_config[\"name\"]\n            if this_pop_name != pop_name:\n                continue\n            if \"immigration\" in pop_config:\n                from_pop = pop_config[\"immigration\"][\"from_pop\"]\n                slider_id = create_immigration_slider_id(from_pop, pop_name)\n                immigration_rate = getattr(input, slider_id)()\n                event = {\n                    \"type\": \"migration_start\",\n                    \"from_pop\": from_pop,\n                    \"to_pop\": pop_name,\n                    \"inmigrant_rate\": immigration_rate,\n                    \"num_generation\": 1,\n                }\n                id = f\"migration_{from_pop}_to_{pop_name}\"\n                demographic_events[id] = event\n        return values, demographic_events\n\n    return calc_pop_values()\n\n\ndef get_pop_ids(config):\n    idss = []\n    for pop_id in sorted(config[\"pops\"].keys()):\n        pop_module_id = f\"module_pop_{pop_id}\"\n        ids = {\"id\": pop_id, \"module_id\": pop_module_id}\n        idss.append(ids)\n    return idss\n\n\ndef create_pops_panel(config):\n    tabs = []\n    for pop_ids in get_pop_ids(config):\n        pop_id = pop_ids[\"id\"]\n        module_id = pop_ids[\"module_id\"]\n        pop_config = config[\"pops\"][pop_id]\n        pop_accordion = create_pop_accordion(module_id, pop_config)\n        pop_name = pop_config[\"name\"]\n        tab = ui.nav_panel(pop_name, pop_accordion)\n        tabs.append(tab)\n\n    if len(tabs) > 1:\n        nav_panel = ui.navset_tab(*tabs, id=\"Populations\")\n        accordion_panel = ui.accordion_panel(\"Populations\", nav_panel)\n    else:\n        accordion_panel = ui.accordion_panel(\"Pop. config.\", pop_accordion)\n    return accordion_panel\n\n\ndef create_num_sims_panel(config):\n    slider = ui.input_slider(\n        id=\"num_simulations_slider\",\n        label=\"\",\n        min=config[\"num_simulations\"][\"min\"],\n        max=config[\"num_simulations\"][\"max\"],\n        value=config[\"num_simulations\"][\"value\"],\n        width=\"100%\",\n    )\n    accordion_panel = ui.accordion_panel(\"Num. simulations\", slider)\n    return accordion_panel\n\n\ndef create_simulation_input_card(config):\n    pops_panel = create_pops_panel(config)\n    num_gen_panel = create_num_gen_panel(config)\n    panels = [pops_panel, num_gen_panel]\n    if \"num_simulations\" in config:\n        num_sim_panel = create_num_sims_panel(config)\n        panels.append(num_sim_panel)\n\n    input_accordion = ui.accordion(*panels, id=\"input_accordion\")\n    run_button = ui.input_action_button(\"run_button\", \"Run simulation\")\n\n    card = ui.card(input_accordion, run_button)\n    return card\n\n\ndef set_config_defaults(config: dict):\n    config.setdefault(\"title\", \"One locus two alleles simulation\")\n\n    if \"pops\" not in config:\n        config[\"pops\"] = {\"pop\": {}}\n\n    pops_config = {}\n    for idx, pop_name in enumerate(config[\"pops\"].keys()):\n        pop_id = f\"pop_{idx}\"\n        pop_config = {}\n        pop_config[\"name\"] = pop_name\n        if (\n            \"freq_A\" in config[\"pops\"][pop_name]\n            and \"genotypic_freqs\" in config[\"pops\"][pop_name]\n        ):\n            raise ValueError(\n                'Either \"freq_A\" or \"genotypic_freqs\" can be set, but not both'\n            )\n        elif \"freq_A\" in config[\"pops\"][pop_name]:\n            pop_config[\"freq_A\"] = config[\"pops\"][pop_name][\"freq_A\"]\n        elif \"genotypic_freqs\" in config[\"pops\"][pop_name]:\n            pop_config[\"genotypic_freqs\"] = config[\"pops\"][pop_name][\"genotypic_freqs\"]\n        else:\n            pop_config[\"freq_A\"] = 0.5\n        pop_config[\"ui_freq_options\"] = config[\"pops\"][pop_name].get(\n            \"ui_freq_options\", (\"genotypic\", \"allelic\")\n        )\n        if \"size\" in config[\"pops\"][pop_name]:\n            pop_config[\"size\"] = config[\"pops\"][pop_name][\"size\"]\n        else:\n            pop_config.setdefault(\"size\", {\"min\": 10, \"max\": 200, \"value\": 100})\n        if pop_config[\"size\"][\"value\"] in (\"inf\", \"inf.\"):\n            pop_config[\"size\"][\"value\"] = INF\n\n        for param in (\"fitness\", \"mutation\", \"selfing_rate\", \"immigration\"):\n            if param in config[\"pops\"][pop_name]:\n                pop_config[param] = config[\"pops\"][pop_name][param]\n\n        pops_config[pop_id] = pop_config\n\n    config[\"pops\"] = pops_config\n\n    config.setdefault(\"num_generations\", {\"min\": 10, \"max\": 300, \"value\": 100})\n    # the panels shown will be the loggers chosen\n    config.setdefault(\n        \"loggers\",\n        (\n            \"allelic_freqs_logger\",\n            \"genotypic_freqs_logger\",\n            \"exp_het_logger\",\n        ),\n    )\n    if \"num_simulations\" in config:\n        num_simulations = config[\"num_simulations\"].setdefault(\"value\", 1)\n        config[\"num_simulations\"].setdefault(\"min\", 1)\n        config[\"num_simulations\"].setdefault(\"max\", max(10, num_simulations))\n\n\ndef app_ui(request):\n    encoded_config = request.query_params.get(\"app_config\")\n    if encoded_config is not None:\n        config = json.loads(unquote(encoded_config))\n    else:\n        config = config_module.CONFIG\n\n    # howto encode\n    encode_config = False\n    if encode_config:\n        encoded = urlencode({\"app_config\": json.dumps(config, separators=(\",\", \":\"))})\n        print(\"encoded\", encoded)\n\n    set_config_defaults(config)\n    sim_config.set(config)\n\n    input_card = create_simulation_input_card(config)\n    output_card = create_simulation_output_card(config)\n\n    page = ui.page_fixed(\n        # This javascript code is a workaround for a shinylive behaviour.\n        # In shinylive the app is located inside an iframe, and that prevents it\n        # from accessing the query parameters directly. This javascript code tries to fix that\n        ui.tags.script(\n            \"if(window.location.search !== window.parent.location.search) { window.location.search = window.parent.location.search }\",\n            type=\"text/JavaScript\",\n        ),\n        ui.h1(config[\"title\"]),\n        input_card,\n        output_card,\n    )\n    return page\n\n\ndef server(input, output, session):\n    @reactive.calc\n    def get_sim_params():\n        config = sim_config.get()\n        pops_params = {}\n        demographic_events = {}\n        for pop_ids in get_pop_ids(config):\n            pop_id = pop_ids[\"id\"]\n            pop_name = config[\"pops\"][pop_id][\"name\"]\n            module_id = pop_ids[\"module_id\"]\n            pops_params[pop_name], pop_demographic_events = pop_input_server(\n                module_id, pop_name, config\n            )\n            demographic_events.update(pop_demographic_events)\n\n        sim_params = {\"pops\": pops_params}\n        sim_params[\"num_generations\"] = input.num_gen_slider()\n        sim_params[\"loggers\"] = config[\"loggers\"]\n        if demographic_events:\n            sim_params[\"demographic_events\"] = demographic_events\n\n        if \"num_simulations_slider\" in input:\n            num_simulations = input.num_simulations_slider()\n        else:\n            num_simulations = config.get(\"num_simulations\", {}).get(\"value\", 1)\n\n        return {\"sim_params\": sim_params, \"num_simulations\": num_simulations}\n\n    @reactive.calc\n    @reactive.event(input.run_button, ignore_none=False)\n    def run_simulations():\n        res = get_sim_params()\n        sims = [\n            OneLocusTwoAlleleSimulation(res[\"sim_params\"])\n            for _ in range(res[\"num_simulations\"])\n        ]\n        return sims\n\n    @render.plot(alt=\"Freq. A plot\")\n    def allelic_freqs_plot():\n        sims = run_simulations()\n\n        fig, axes = plt.subplots()\n        axes.set_title(\"Freq. A\")\n        axes.set_xlabel(\"generation\")\n        axes.set_ylabel(\"freq\")\n\n        colors = {}\n        for sim in sims:\n            freqs_dframe = sim.results[\"allelic_freqs\"]\n            for pop, pop_allelic_freqs in freqs_dframe.items():\n                color = colors.setdefault(pop, next(style.COLOR_CYCLE))\n                axes.plot(\n                    pop_allelic_freqs.index,\n                    pop_allelic_freqs.values,\n                    label=pop,\n                    color=color,\n                )\n\n        num_pops = freqs_dframe.shape[1]\n        if num_pops > 1:\n            axes.legend()\n\n        axes.set_ylim((0, 1))\n        return fig\n\n    @render.data_frame\n    def allelic_freqs_df():\n        sims = run_simulations()\n        pops = []\n        sims_idxs = []\n        initial_freqs = []\n        final_freqs = []\n        for sim_idx, sim in enumerate(sims):\n            for pop, freqs_series in sim.results[\"allelic_freqs\"].items():\n                pops.append(pop)\n                sims_idxs.append(sim_idx)\n                initial_freqs.append(round(float(freqs_series.iloc[0]), ndigits=2))\n                final_freqs.append(round(float(freqs_series.iloc[-1]), ndigits=2))\n        freqs = {}\n        if len(sims) > 1:\n            freqs[\"Simulation\"] = sims_idxs\n        freqs[\"Population\"] = pops\n        freqs[\"Initial freq.\"] = initial_freqs\n        freqs[\"Final freq.\"] = final_freqs\n        freqs_df = pandas.DataFrame(freqs)\n        return render.DataTable(freqs_df)\n\n    @render.ui\n    def genotypic_plots():\n        sims = run_simulations()\n\n        sim = sims[0]\n        genotypic_freqs = sim.results[\"genotypic_freqs\"]\n        geno_freqs_labels = sorted(genotypic_freqs.keys())\n        first_label = geno_freqs_labels[0]\n        pop_names = genotypic_freqs[first_label].columns\n\n        plots = {}\n        for pop in pop_names:\n            module_id = f\"geno_freqs_plot_{pop}\"\n            # Dynamically create UI components for each plot\n            plot = genotypic_plot_ui(module_id)\n            plots[pop] = plot\n\n            geno_freqs = {}\n            for geno_freq_label in geno_freqs_labels:\n                geno_freqs[geno_freq_label] = [\n                    sim.results[\"genotypic_freqs\"][geno_freq_label][pop] for sim in sims\n                ]\n            # Dynamically create server-side functions for each plot\n            genotypic_plot_server(module_id, geno_freqs=geno_freqs)\n\n        if len(plots) == 1:\n            output_content = plot\n        else:\n            panels = [ui.nav_panel(pop_name, plot) for pop_name, plot in plots.items()]\n            navset_tab = ui.navset_tab(*panels, id=\"geno_freqs_navset\")\n            output_content = navset_tab\n\n        return output_content\n\n    @render.plot(alt=\"Exp. Het.\")\n    def exp_het_plot():\n        sims = run_simulations()\n\n        fig, axes = plt.subplots()\n        axes.set_title(\"Expected Het.\")\n        axes.set_xlabel(\"generation\")\n        axes.set_ylabel(\"Exp. Het.\")\n\n        colors = {}\n        for sim in sims:\n            exp_hets_dframe = sim.results[\"expected_hets\"]\n\n            for pop, pop_exp_hets in exp_hets_dframe.items():\n                color = colors.setdefault(pop, next(style.COLOR_CYCLE))\n                axes.plot(\n                    pop_exp_hets.index, pop_exp_hets.values, label=pop, color=color\n                )\n\n        num_pops = exp_hets_dframe.shape[1]\n        if num_pops > 1:\n            axes.legend()\n\n        axes.set_ylim((0, 0.6))\n        return fig\n\n    @render.data_frame\n    def expected_hets_df():\n        sims = run_simulations()\n        pops = []\n        sims_idxs = []\n        initial_freqs = []\n        final_freqs = []\n        for sim_idx, sim in enumerate(sims):\n            for pop, freqs_series in sim.results[\"expected_hets\"].items():\n                pops.append(pop)\n                sims_idxs.append(sim_idx)\n                initial_freqs.append(round(float(freqs_series.iloc[0]), ndigits=2))\n                final_freqs.append(round(float(freqs_series.iloc[-1]), ndigits=2))\n        freqs = {}\n        if len(sims) > 1:\n            freqs[\"Simulation\"] = sims_idxs\n        freqs[\"Population\"] = pops\n        freqs[\"Initial exp. het.\"] = initial_freqs\n        freqs[\"Final exp. het.\"] = final_freqs\n        freqs_df = pandas.DataFrame(freqs)\n        return render.DataTable(freqs_df)\n\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "config.py", "content": "CONFIG = {}\n", "type": "text"}, {"name": "one_locus_two_alleles_simulator.py", "content": "from typing import Callable, Iterable\nimport random\nimport math\nfrom array import array\nfrom collections import defaultdict, namedtuple\nimport copy\n\nimport numpy\nimport pandas\n\nINF = math.inf\n\nMENDELIAN_SEGREGATIONS = {\n    (\"AA\", \"AA\"): [(1, 0, 0)],\n    (\"aa\", \"aa\"): [(0, 0, 1)],\n    (\"AA\", \"aa\"): [(0, 1, 0)],\n    (\"aa\", \"AA\"): [(0, 1, 0)],\n    (\"AA\", \"Aa\"): ((1, 0, 0), (0, 1, 0)),\n    (\"Aa\", \"AA\"): ((1, 0, 0), (0, 1, 0)),\n    (\"aa\", \"Aa\"): ((0, 0, 1), (0, 1, 0)),\n    (\"Aa\", \"aa\"): ((0, 0, 1), (0, 1, 0)),\n    (\"Aa\", \"Aa\"): (\n        (1, 0, 0),\n        (0, 1, 0),\n        (0, 1, 0),\n        (0, 0, 1),\n    ),\n}\n\n\nclass GenotypicFreqs:\n    def __init__(self, freq_AA: float, freq_Aa: float, freq_aa: float | None = None):\n        freq_AA = float(freq_AA)\n        freq_Aa = float(freq_Aa)\n\n        if freq_AA > 1:\n            raise ValueError(\"freq AA can not be larger than 1\")\n        if freq_AA < 0:\n            raise ValueError(\"freq AA can not be lower than 0\")\n        if freq_Aa < 0:\n            raise ValueError(\"freq Aa can not be lower than 0\")\n        if freq_AA + freq_Aa > 1:\n            raise ValueError(\"AA + Aa freqs cannot be greater than 1\")\n\n        self._AA = freq_AA\n        self._Aa = freq_Aa\n        expected_freq_aa = 1 - self._AA - self._Aa\n        if freq_aa is not None:\n            if freq_aa < 0:\n                raise ValueError(\"freq A0 can not be lower than 0\")\n            if not math.isclose(expected_freq_aa, freq_aa, abs_tol=0.01):\n                raise ValueError(\n                    f\"freq_aa ({freq_aa}) should be 1 - freq_AA - freq_Aa ({expected_freq_aa})\"\n                )\n        freq_aa = expected_freq_aa\n\n        if not math.isclose(freq_aa + freq_AA + freq_Aa, 1):\n            raise ValueError(\"Genotypic freqs should sum 1\")\n        self._aa = freq_aa\n\n    @property\n    def freqs(self):\n        return (self.AA, self.Aa, self.aa)\n\n    @property\n    def A(self):\n        return self._AA + self._Aa * 0.5\n\n    @property\n    def AA(self):\n        return self._AA\n\n    @property\n    def Aa(self):\n        return self._Aa\n\n    @property\n    def aa(self):\n        return self._aa\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self.AA}, {self.Aa}, {self.aa})\"\n\n\nclass AllelicFreqs:\n    def __init__(self, freq_A):\n        self.A = freq_A\n        freq_a = 1 - freq_A\n        self.a = freq_a\n        if not math.isclose(freq_A + freq_a, 1):\n            raise ValueError(\"Allelic freqs should sum 1\")\n\n    def __str__(self):\n        return f\"A: {self.A}, a: {self.a}\"\n\n\nclass Fitness:\n    def __init__(self, w11, w12, w22):\n        if numpy.allclose([w11, w12, w22], [0, 0, 0]):\n            raise ValueError(\"Some of the fitness values should be non zero\")\n        self.w11 = w11\n        self.w12 = w12\n        self.w22 = w22\n\n\nMutRates = namedtuple(\"MutRates\", (\"A2a\", \"a2A\"))\n\n\ndef calc_allelic_freq(genotypic_freqs: GenotypicFreqs):\n    return genotypic_freqs.AA + genotypic_freqs.Aa * 0.5\n\n\ndef calc_allelic_freqs(genotypic_freqs: GenotypicFreqs):\n    return AllelicFreqs(calc_allelic_freq(genotypic_freqs))\n\n\ndef calc_hwe_genotypic_freqs(allelic_freqs: AllelicFreqs):\n    freq_AA = allelic_freqs.A**2\n    freq_Aa = 2 * allelic_freqs.A * allelic_freqs.a\n    return GenotypicFreqs(freq_AA, freq_Aa)\n\n\nclass Population:\n    def __init__(\n        self,\n        id: str,\n        genotypic_freqs: GenotypicFreqs,\n        size: int | float = INF,\n        fitness: Fitness | None = None,\n        mut_rates: MutRates | None = None,\n        selfing_rate: float = 0.0,\n    ):\n        self.id = id\n        self.size = size\n        self.genotypic_freqs = genotypic_freqs\n        self.selfing_rate = selfing_rate\n\n        self.fitness = fitness\n\n        self.mut_rates = mut_rates\n\n    @property\n    def allelic_freqs(self):\n        genotypic_freqs = self.genotypic_freqs\n        return AllelicFreqs(calc_allelic_freq(genotypic_freqs))\n\n    def _choose_parent(self, freq_AA, freq_Aa):\n        value = random.uniform(0, 1)\n        if value < freq_AA:\n            return \"AA\"\n        elif value >= (freq_AA + freq_Aa):\n            return \"aa\"\n        else:\n            return \"Aa\"\n\n    def evolve_to_next_generation(self, migration_origins=None):\n        genotypic_freqs = self.genotypic_freqs\n\n        if migration_origins is None:\n            migration_origins = []\n\n        freq_AA = genotypic_freqs.AA\n        freq_Aa = genotypic_freqs.Aa\n\n        # migration\n        this_pop_contribution = 1 - sum(\n            [origin[\"inmigrant_rate\"] for origin in migration_origins]\n        )\n        if this_pop_contribution < 0:\n            raise ValueError(f\"Too many inmigrants for pop {self.id}, more than 100%\")\n\n        freq_AA = this_pop_contribution * freq_AA + sum(\n            [\n                origin[\"from_pop\"].genotypic_freqs.AA * origin[\"inmigrant_rate\"]\n                for origin in migration_origins\n            ]\n        )\n        freq_Aa = this_pop_contribution * freq_Aa + sum(\n            [\n                origin[\"from_pop\"].genotypic_freqs.Aa * origin[\"inmigrant_rate\"]\n                for origin in migration_origins\n            ]\n        )\n        freq_aa = this_pop_contribution * genotypic_freqs.aa + sum(\n            [\n                origin[\"from_pop\"].genotypic_freqs.aa * origin[\"inmigrant_rate\"]\n                for origin in migration_origins\n            ]\n        )\n        assert math.isclose(freq_AA + freq_Aa + freq_aa, 1)\n\n        # selection\n        fitness = self.fitness\n        if fitness is not None:\n            freq_AA = freq_AA * fitness.w11\n            freq_Aa = freq_Aa * fitness.w12\n            freq_aa = freq_aa * fitness.w22\n            sum_freqs = freq_AA + freq_Aa + freq_aa\n            freq_AA = freq_AA / sum_freqs\n            freq_Aa = freq_Aa / sum_freqs\n            freq_aa = freq_aa / sum_freqs\n            assert math.isclose(freq_AA + freq_Aa + freq_aa, 1)\n\n        # mutation\n        if self.mut_rates:\n            mu = self.mut_rates.A2a\n            mu2 = mu**2\n            nu = self.mut_rates.a2A\n            nu2 = nu**2\n            AA0 = freq_AA\n            Aa0 = freq_Aa\n            aa0 = 1 - freq_AA - freq_Aa\n\n            new_aa = AA0 * mu2 + Aa0 * mu\n            new_AA = aa0 * nu2 + Aa0 * nu\n            new_Aa = 2 * AA0 * mu + 2 * aa0 * nu\n            AA_removed = AA0 * mu2 + 2 * AA0 * mu\n            aa_removed = aa0 * nu2 + 2 * aa0 * nu\n            Aa_removed = Aa0 * mu + Aa0 * nu\n\n            AA1 = AA0 + new_AA - AA_removed\n            Aa1 = Aa0 + new_Aa - Aa_removed\n            aa1 = aa0 + new_aa - aa_removed\n            assert math.isclose(AA1 + Aa1 + aa1, 1)\n            freq_AA = AA1\n            freq_Aa = Aa1\n\n        # drift\n        selfing_rate = self.selfing_rate\n        if self.size is None or math.isinf(self.size):\n            # selfed indivuals\n            selfed_freq_AA1 = freq_AA + freq_Aa * 0.25\n            selfed_freq_Aa1 = freq_Aa * 0.5\n            # non selfed individuals\n            allelic_freqs = calc_allelic_freqs(GenotypicFreqs(freq_AA, freq_Aa))\n            panmix_genotypic_freqs = calc_hwe_genotypic_freqs(allelic_freqs)\n            # final freqs\n            freq_AA = selfed_freq_AA1 * selfing_rate + panmix_genotypic_freqs.AA * (\n                1 - selfing_rate\n            )\n            freq_Aa = selfed_freq_Aa1 * selfing_rate + panmix_genotypic_freqs.Aa * (\n                1 - selfing_rate\n            )\n        else:\n            num_AA = 0\n            num_Aa = 0\n            num_aa = 0\n            for _ in range(self.size):\n                parent1 = self._choose_parent(freq_AA, freq_Aa)\n\n                parent2 = None\n                if selfing_rate is not None:\n                    value = random.uniform(0, 1)\n                    if value < selfing_rate:\n                        parent2 = parent1\n                if parent2 is None:\n                    parent2 = self._choose_parent(freq_AA, freq_Aa)\n\n                mendelian_choices = MENDELIAN_SEGREGATIONS[(parent1, parent2)]\n                if len(mendelian_choices) == 1:\n                    descendants = mendelian_choices[0]\n                else:\n                    descendants = random.choice(mendelian_choices)\n                num_AA += descendants[0]\n                num_Aa += descendants[1]\n                num_aa += descendants[2]\n\n            total_indis = num_AA + num_Aa + num_aa\n            assert total_indis == self.size\n\n            freq_AA = num_AA / total_indis\n            freq_Aa = num_Aa / total_indis\n\n        self.genotypic_freqs = GenotypicFreqs(freq_AA, freq_Aa)\n\n\ndef _update_events(demographic_events, num_generation, active_migrations):\n    for event in demographic_events:\n        event_num_generation = event.get(\"num_generation\")\n        if event_num_generation is not None and event_num_generation != num_generation:\n            continue\n\n        if event[\"type\"] == \"size_change\":\n            event[\"pop\"].size = event[\"new_size\"]\n        elif event[\"type\"] == \"migration_start\":\n            active_migrations[event[\"id\"]] = event\n        elif event[\"type\"] == \"migration_stop\":\n            del active_migrations[event[\"migration_id\"]]\n\n\ndef simulate_forward_in_time(\n    pops: list[Population],\n    num_generations: int,\n    loggers: list[Callable],\n    demographic_events: list[dict] | None = None,\n    random_seed: int | None = None,\n):\n    if random_seed is not None:\n        numpy.random.seed(random_seed)\n        random.seed(random_seed)\n\n    for logger in loggers:\n        logger(pops, num_generation=1)\n\n    if demographic_events is None:\n        demographic_events = []\n    active_migrations = {}\n    _update_events(demographic_events, 1, active_migrations)\n\n    for num_generation in range(2, num_generations + 1):\n        _update_events(demographic_events, num_generation, active_migrations)\n\n        for pop in pops:\n            migration_origin_pops = defaultdict(list)\n            for migration in active_migrations.values():\n                if migration[\"to_pop\"].id == pop.id:\n                    migration_origin_pops[pop.id].append(\n                        {\n                            \"from_pop\": migration[\"from_pop\"],\n                            \"inmigrant_rate\": migration[\"inmigrant_rate\"],\n                        }\n                    )\n            pop.evolve_to_next_generation(migration_origin_pops[pop.id])\n\n        for logger in loggers:\n            logger(pops, num_generation)\n\n\nclass _PerPopLogger:\n    def __init__(self):\n        self._values_per_generation = None\n        self._generations = array(\"L\")\n\n    @classmethod\n    def from_loggers(cls, loggers):\n        logger = cls()\n        logger._values_per_generation = pandas.concat(\n            [logger.values_per_generation for logger in loggers], axis=1\n        )\n        logger._generations = logger._values_per_generation.index\n        return logger\n\n    def __call__(self, pops: Iterable[Population], num_generation: int):\n        self._generations.append(num_generation)\n\n        if self._values_per_generation is None:\n            values = {pop.id: array(\"f\") for pop in pops}\n            self._values_per_generation = values\n        else:\n            values = self._values_per_generation\n\n        for pop in pops:\n            values[pop.id].append(self._calc_value_for_pop(pop))\n\n    @property\n    def values_per_generation(self):\n        values = self._values_per_generation\n        values = pandas.DataFrame(values, index=self._generations)\n        return values\n\n\nclass AllelicFreqLogger(_PerPopLogger):\n    def _calc_value_for_pop(self, pop):\n        return calc_allelic_freq(pop.genotypic_freqs)\n\n\nclass PopSizeLogger(_PerPopLogger):\n    def _calc_value_for_pop(self, pop):\n        size = pop.size\n        if size is None:\n            size = math.inf\n        return size\n\n\nclass ExpHetLogger(_PerPopLogger):\n    def _calc_value_for_pop(self, pop):\n        freq_A = calc_allelic_freq(pop.genotypic_freqs)\n        exp_het = 2 * freq_A * (1 - freq_A)\n        return exp_het\n\n\nGENOTYPIC_FREQS_NAMES = [\"freqs_AA\", \"freqs_Aa\", \"freqs_aa\"]\n\n\nclass GenotypicFreqsLogger:\n    def __init__(self):\n        self._values_per_generation = None\n        self._generations = array(\"L\")\n\n    @classmethod\n    def from_loggers(cls, loggers):\n        logger = cls()\n        values = {}\n        for genotypic_freq_name in loggers[0].values_per_generation.keys():\n            values[genotypic_freq_name] = pandas.concat(\n                [\n                    logger.values_per_generation[genotypic_freq_name]\n                    for logger in loggers\n                ],\n                axis=1,\n            )\n\n        logger._values_per_generation = values\n        logger._generations = values[genotypic_freq_name].index\n        return logger\n\n    def __call__(self, pops: Iterable[Population], num_generation: int):\n        self._generations.append(num_generation)\n\n        if self._values_per_generation is None:\n            values = {}\n            for genotypic_freq_name in GENOTYPIC_FREQS_NAMES:\n                values[genotypic_freq_name] = {}\n                for pop in pops:\n                    values[genotypic_freq_name][pop.id] = array(\"f\")\n            self._values_per_generation = values\n        else:\n            values = self._values_per_generation\n\n        for pop in pops:\n            for genotypic_freq_name, value in zip(\n                GENOTYPIC_FREQS_NAMES, pop.genotypic_freqs.freqs\n            ):\n                values[genotypic_freq_name][pop.id].append(value)\n\n    @property\n    def values_per_generation(self):\n        values = self._values_per_generation\n        dframes = {}\n        for genotypic_freq_name, freqs in values.items():\n            dframes[genotypic_freq_name] = pandas.DataFrame(\n                freqs, index=self._generations\n            )\n        return dframes\n\n\nLOGGER_CLASSES = {\n    \"allelic_freqs_logger\": AllelicFreqLogger,\n    \"pop_size_logger\": PopSizeLogger,\n    \"genotypic_freqs_logger\": GenotypicFreqsLogger,\n    \"exp_het_logger\": ExpHetLogger,\n}\nLOGGER_PARAMETERS = {\n    AllelicFreqLogger: \"allelic_freqs\",\n    PopSizeLogger: \"pop_sizes\",\n    GenotypicFreqsLogger: \"genotypic_freqs\",\n    ExpHetLogger: \"expected_hets\",\n}\n\n\nclass OneLocusTwoAlleleSimulation:\n    def __init__(self, sim_definition: dict):\n        sim_definition = copy.deepcopy(sim_definition)\n        pops = self._create_pops(sim_definition[\"pops\"])\n        events = self._create_demographic_events(\n            sim_definition.get(\"demographic_events\", {}), pops\n        )\n        loggers = self._create_loggers(sim_definition[\"loggers\"])\n        simulate_forward_in_time(\n            list(pops.values()),\n            num_generations=sim_definition[\"num_generations\"],\n            demographic_events=events,\n            loggers=loggers,\n        )\n        self.results = self._gather_results(loggers)\n\n    @staticmethod\n    def _create_pops(pop_definitions):\n        pops = {}\n        for pop_id in sorted(pop_definitions.keys()):\n            pop_def = pop_definitions[pop_id]\n            kwargs = {}\n            kwargs[\"genotypic_freqs\"] = GenotypicFreqs(*pop_def[\"genotypic_freqs\"])\n            if \"size\" in pop_def:\n                kwargs[\"size\"] = pop_def[\"size\"]\n            if \"fitness\" in pop_def:\n                kwargs[\"fitness\"] = Fitness(*pop_def[\"fitness\"])\n            if \"mut_rates\" in pop_def:\n                kwargs[\"mut_rates\"] = MutRates(*pop_def[\"mut_rates\"])\n            kwargs[\"selfing_rate\"] = float(pop_def.get(\"selfing_rate\", 0.0))\n\n            pops[pop_id] = Population(pop_id, **kwargs)\n        return pops\n\n    @staticmethod\n    def _create_demographic_events(demographic_events, pops):\n        events = []\n        for event_id, event in demographic_events.items():\n            event[\"id\"] = event_id\n            for key in [\"pop\", \"from_pop\", \"to_pop\"]:\n                if key in event:\n                    event[key] = pops[event[key]]\n            events.append(event)\n        return events\n\n    @staticmethod\n    def _create_loggers(loggers):\n        logger_objs = []\n        for logger in loggers:\n            logger_objs.append(LOGGER_CLASSES[logger]())\n        return logger_objs\n\n    @staticmethod\n    def _gather_results(loggers):\n        results = {}\n        for logger in loggers:\n            param = LOGGER_PARAMETERS[logger.__class__]\n            values = logger.values_per_generation\n            results[param] = values\n        return results\n\n\ndef simulate(\n    pops: list[Population],\n    num_generations: int,\n    loggers: list[Callable],\n    demographic_events: list[dict] | None = None,\n    random_seed: int | None = None,\n):\n    if random_seed is not None:\n        numpy.random.seed(random_seed)\n        random.seed(random_seed)\n\n    for logger in loggers:\n        logger(pops, num_generation=1)\n\n    if demographic_events is None:\n        demographic_events = []\n    active_migrations = {}\n    _update_events(demographic_events, 1, active_migrations)\n\n    for num_generation in range(2, num_generations + 1):\n        _update_events(demographic_events, num_generation, active_migrations)\n\n        for pop in pops:\n            migration_origin_pops = defaultdict(list)\n            for migration in active_migrations.values():\n                if migration[\"to_pop\"].id == pop.id:\n                    migration_origin_pops[pop.id].append(\n                        {\n                            \"from_pop\": migration[\"from_pop\"],\n                            \"inmigrant_rate\": migration[\"inmigrant_rate\"],\n                        }\n                    )\n            pop.evolve_to_next_generation(migration_origin_pops[pop.id])\n\n        for logger in loggers:\n            logger(pops, num_generation)\n\n\ndef simulate_one_locus_two_alleles_one_pop(\n    freq_AA,\n    freq_Aa,\n    freq_aa,\n    pop_size=INF,\n    num_generations=100,\n    w11=1,\n    w12=1,\n    w22=1,\n    A2a=0,\n    a2A=0,\n    selfing_rate=0,\n    num_populations=1,\n):\n    if (w11, w12, w22) == (1, 1, 1):\n        fitness = None\n    else:\n        fitness = Fitness(w11=w11, w12=w12, w22=w22)\n\n    if A2a == 0 and a2A == 0:\n        mut_rates = None\n    else:\n        mut_rates = MutRates(A2a, a2A)\n\n    loggers = {\n        \"genotypic_freqs_logger\": [],\n        \"allelic_freqs_logger\": [],\n        \"exp_het_logger\": [],\n    }\n    for idx in range(num_populations):\n        genotypic_freqs = GenotypicFreqs(\n            freq_AA=freq_AA, freq_Aa=freq_Aa, freq_aa=freq_aa\n        )\n        pop = Population(\n            id=f\"pop{idx}\",\n            size=pop_size,\n            genotypic_freqs=genotypic_freqs,\n            fitness=fitness,\n            mut_rates=mut_rates,\n            selfing_rate=selfing_rate,\n        )\n\n        allelic_freqs_logger = AllelicFreqLogger()\n        genotypic_freqs_logger = GenotypicFreqsLogger()\n        exp_het_logger = ExpHetLogger()\n        simulate(\n            pops=[pop],\n            num_generations=num_generations,\n            demographic_events=None,\n            random_seed=None,\n            loggers=[allelic_freqs_logger, genotypic_freqs_logger, exp_het_logger],\n        )\n        loggers[\"genotypic_freqs_logger\"].append(genotypic_freqs_logger)\n        loggers[\"allelic_freqs_logger\"].append(allelic_freqs_logger)\n        loggers[\"exp_het_logger\"].append(exp_het_logger)\n\n    loggers = {\n        key: logger_list[0].__class__.from_loggers(logger_list)\n        for key, logger_list in loggers.items()\n    }\n\n    return loggers\n", "type": "text"}, {"name": "style.py", "content": "import itertools\n\nimport matplotlib.pyplot as plt\n\nCOLORS = list(plt.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"])\nCOLOR_CYCLE = itertools.cycle(COLORS)\n\nMARKERS = [\n    (\"o\", True),\n    (\"x\", True),\n    (\"s\", False),\n    (\"v\", True),\n    (\"^\", True),\n    (\"<\", True),\n    (\">\", True),\n    (\"p\", True),\n    (\"*\", True),\n    (\"h\", True),\n    (\"H\", True),\n    (\"D\", True),\n    (\"d\", True),\n]\nMARKER_CYCLE = itertools.cycle(MARKERS)\n\nLINESTYLES = [\"solid\", \"dashed\", \"dotted\", \"-.\"]\nLINESTYLES_CYCLE = itertools.cycle(LINESTYLES)\n", "type": "text"}]